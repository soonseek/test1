## 파일: src/types/pokemon.ts

```typescript
/**
 * PokeAPI 리스트 응답 내부의 개별 아이템 형태
 */
export interface PokeApiListItem {
  name: string;
  url: string;
}

/**
 * PokeAPI 리스트 전체 응답 형태
 */
export interface PokeApiListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokeApiListItem[];
}

/**
 * 클라이언트로 반환할 최종 데이터 형태
 */
export interface PokemonListItem {
  id: number;
  name: string;
}
```

## 파일: src/lib/api/pokemon.ts

```typescript
import { PokeApiListResponse, PokemonListItem, PokeApiListItem } from '@/types/pokemon';

const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2/pokemon';

/**
 * PokeAPI로부터 포켓몬 리스트를 페칭합니다.
 * @param offset 시작 위치
 * @param limit 가져올 개수
 * @returns PokeApiListResponse
 */
export async function getPokemonsFromApi(offset: number, limit: number): Promise<PokeApiListResponse> {
  const url = new URL(POKEAPI_BASE_URL);
  url.searchParams.append('offset', String(offset));
  url.searchParams.append('limit', String(limit));

  try {
    const response = await fetch(url.toString(), {
      // Next.js 캐싱 전략 (선택 사항: force-no-store, no-store 등)
      next: { revalidate: 60 } 
    });

    if (!response.ok) {
      throw new Error(`PokeAPI fetch failed: ${response.status} ${response.statusText}`);
    }

    const data: PokeApiListResponse = await response.json();
    return data;
  } catch (error) {
    // 네트워크 에러나 파싱 에러를 처리하여 상위 계층으로 전파
    if (error instanceof Error) {
      throw error;
    }
    throw new Error('Unknown error occurred while fetching PokeAPI');
  }
}

/**
 * URL에서 ID를 추출하는 헬퍼 함수
 * 예: https://pokeapi.co/api/v2/pokemon/1/ -> 1
 */
function extractIdFromUrl(url: string): number {
  const parts = url.trim().split('/');
  const idPart = parts[parts.length - 2]; // 뒤에서 두 번째 부분이 ID
  return parseInt(idPart, 10);
}

/**
 * API 응답의 results 배열을 클라이언트에 맞게 매핑합니다.
 */
export function mapToPokemonList(items: PokeApiListItem[]): PokemonListItem[] {
  return items.map((item) => {
    const id = extractIdFromUrl(item.url);
    return {
      id,
      name: item.name,
    };
  });
}
```

## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getPokemonsFromApi, mapToPokemonList } from '@/lib/api/pokemon';
import { PokemonListItem } from '@/types/pokemon';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // 쿼리 파라미터 파싱 및 기본값 설정
    const rawOffset = searchParams.get('offset');
    const rawLimit = searchParams.get('limit');

    const offset = rawOffset ? parseInt(rawOffset, 10) : 0;
    const limit = rawLimit ? parseInt(rawLimit, 10) : 20;

    // 유효성 검사 (간단한 체크)
    if (isNaN(offset) || isNaN(limit) || offset < 0 || limit < 0) {
      return NextResponse.json(
        { error: 'Invalid query parameters. offset and limit must be positive integers.' },
        { status: 400 }
      );
    }

    // 외부 API 호출
    const apiResponse = await getPokemonsFromApi(offset, limit);

    // 데이터 변환 (매핑)
    const results: PokemonListItem[] = mapToPokemonList(apiResponse.results);

    // TODO: 향후 Prisma 로직이 추가될 위치
    // 예: await prisma.pokemonCache.createMany({ data: results });

    // 클라이언트에 JSON 응답 반환
    return NextResponse.json(results, { status: 200 });

  } catch (error) {
    console.error('Error in /api/pokemon:', error);
    
    const errorMessage = error instanceof Error ? error.message : 'Internal Server Error';
    
    return NextResponse.json(
      { error: errorMessage },
      { status: 500 }
    );
  }
}
```
```markdown
## 파일: src/types/pokemon.ts

```typescript
/**
 * PokeAPI v2 pokemon 리스트 엔드포인트의 원본 응답 형태
 */
export interface PokeAPIListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokeAPIResult[];
}

/**
 * PokeAPI 리스트 내 개별 아이템 형태
 */
export interface PokeAPIResult {
  name: string;
  url: string;
}

/**
 * 클라이언트로 반환할 최종 데이터 형태
 */
export interface PokemonListItem {
  id: number;
  name: string;
}

/**
 * 포켓몬 타입(속성) 데이터 형태
 */
export interface PokeAPIType {
  name: string;
  url: string;
}
```

## 파일: src/lib/api/pokemon.ts

```typescript
import { PokeAPIListResponse, PokemonListItem } from '@/types/pokemon';

const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2';

/**
 * PokeAPI에서 포켓몬 리스트를 비동기로 가져오는 함수
 * @param limit 가져올 아이템 개수
 * @param offset 시작 위치
 * @returns PokemonListItem[]
 */
export async function fetchPokemonList(
  limit: number = 20,
  offset: number = 0
): Promise<PokemonListItem[]> {
  try {
    const response = await fetch(
      `${POKEAPI_BASE_URL}/pokemon?limit=${limit}&offset=${offset}`,
      {
        // Next.js 내장 fetch의 캐싱 전략 설정
        // 데이터 변경이 잦지 않으므로 시간 기반 재검증 사용 (force-cache는 빌드 타임 캐싱 시 유용)
        next: { revalidate: 60 }, 
      }
    );

    if (!response.ok) {
      throw new Error(`PokeAPI fetch failed: ${response.statusText}`);
    }

    const data: PokeAPIListResponse = await response.json();

    // URL에서 ID 추출 및 매핑 로직
    // URL 예시: https://pokeapi.co/api/v2/pokemon/1/
    const mappedData: PokemonListItem[] = data.results.map((item) => {
      const urlSegments = item.url.split('/').filter(Boolean);
      const id = Number(urlSegments[urlSegments.length - 1]);

      return {
        id,
        name: item.name,
      };
    });

    return mappedData;
  } catch (error) {
    console.error('Error in fetchPokemonList:', error);
    throw new Error('Failed to fetch pokemon data from external API');
  }
}
```

## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { fetchPokemonList } from '@/lib/api/pokemon';

/**
 * GET /api/pokemon
 * 포켓몬 리스트 데이터를 JSON 형식으로 반환하는 핸들러
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // 쿼리 파라미터 파싱 및 검증
    const limitParam = searchParams.get('limit');
    const offsetParam = searchParams.get('offset');

    const limit = limitParam ? parseInt(limitParam, 10) : 20;
    const offset = offsetParam ? parseInt(offsetParam, 10) : 0;

    // NaN 검증 및 기본값 처리
    const validLimit = Number.isNaN(limit) ? 20 : limit;
    const validOffset = Number.isNaN(offset) ? 0 : offset;

    // 데이터 페칭
    const data = await fetchPokemonList(validLimit, validOffset);

    // JSON 반환
    return NextResponse.json(data);
  } catch (error) {
    // 에러 발생 시 500 상태 코드와 메시지 반환
    console.error('API Route Error:', error);
    return NextResponse.json(
      { error: 'Internal Server Error', message: 'Failed to fetch pokemon list' },
      { status: 500 }
    );
  }
}
```

## 파일: src/app/api/pokemon/test/route.spec.ts

```typescript
/**
 * API Route 로컬 테스트 및 데이터 검증
 * 
 * 주의: 이 파일은 Node.js 환경에서 실행되는 테스트 코드입니다.
 * 실제 프로젝트에서는 Jest, Vitest 등의 테스트 러너 설정이 필요합니다.
 * 
 * 실행 방법 (가정):
 * 1. 프로젝트 루트에서 `npm install --save-dev vitest @types/node` 등 설치
 * 2. next dev 서버가 로컬에서 실행 중이어야 합니다 (http://localhost:3000)
 * 3. 테스트 러너 실행
 */

import { describe, it, expect, beforeAll } from 'vitest'; // 또는 'jest'
import { fetch } from 'whatwg-fetch'; // Node 환경에서 fetch 사용을 위한 polyfill (필요시)

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000';

describe('Pokemon API Route Test', () => {
  const endpoint = `${API_BASE_URL}/api/pokemon`;

  it('should return status 200', async () => {
    const response = await fetch(endpoint);
    expect(response.status).toBe(200);
  });

  it('should return a valid JSON array', async () => {
    const response = await fetch(endpoint);
    const data = await response.json();
    
    expect(Array.isArray(data)).toBe(true);
  });

  it('should return items with correct schema (id, name)', async () => {
    const response = await fetch(endpoint);
    const data = await response.json();

    if (data.length > 0) {
      const firstItem = data[0];
      
      // id가 숫자인지 확인
      expect(typeof firstItem.id).toBe('number');
      
      // name이 문자열인지 확인
      expect(typeof firstItem.name).toBe('string');
      
      // 불필요한 프로퍼티가 없는지 간단히 확인 (선택 사항)
      expect(Object.keys(firstItem)).toEqual(expect.arrayContaining(['id', 'name']));
    }
  });

  it('should handle query parameters (limit, offset)', async () => {
    const limit = 5;
    const response = await fetch(`${endpoint}?limit=${limit}`);
    const data = await response.json();

    expect(data.length).toBeLessThanOrEqual(limit);
  });

  it('should handle invalid query parameters gracefully (default fallback)', async () => {
    // limit에 숫자가 아닌 값 전달
    const response = await fetch(`${endpoint}?limit=abc`);
    const data = await response.json();

    // 서버가 기본값(20)을 사용하여 정상 응답하는지 확인
    expect(response.status).toBe(200);
    expect(Array.isArray(data)).toBe(true);
  });
});
```
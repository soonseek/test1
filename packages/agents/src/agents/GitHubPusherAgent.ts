import { Agent, AgentExecutionResult, AgentStatus, CompletionMode } from '@magic-wand/agent-framework';
import { execa } from 'execa';
import fs from 'fs-extra';
import path from 'path';
import { prisma } from '@magic-wand/db';
import { Octokit } from '@octokit/rest';

interface GitHubPusherInput {
  projectId: string;
  codeDirectory: string;
  githubRepoUrl: string;
  githubPat: string;
  commitMessage?: string;
}

interface GitHubPusherOutput {
  pushResult: {
    commitSha: string;
    branch: string;
    repositoryUrl: string;
    filesPushed: number;
  };
}

export class GitHubPusherAgent extends Agent {
  constructor() {
    super({
      agentId: 'github-pusher',
      name: 'GitHub í‘¸ì…”',
      role: 'ìƒì„±ëœ ì½”ë“œë¥¼ GitHub ë ˆí¬ì§€í† ë¦¬ì— í‘¸ì‹œ',
      trigger: {
        type: 'dependency_satisfied',
        dependencies: ['code-generator'],
        condition: 'code_generator.status == "success" OR code_generator.status == "partial"',
      },
      completionMode: CompletionMode.AUTO_CLOSE,
      maxRetries: 3,
      timeout: 300, // 5ë¶„
      dependencies: ['code-generator'],
      contextSharing: {
        sharesTo: ['netlify-deployer', 'issue-resolver'],
        data: ['github_commit_sha', 'github_branch'],
      },
    });

    this.gitConfig = {
      userName: 'MAGIC WAND',
      userEmail: 'magic-wand@automation.local',
    };
  }

  private gitConfig: {
    userName: string;
    userEmail: string;
  };

  async execute(input: GitHubPusherInput): Promise<AgentExecutionResult> {
    await this.log('GitHub í‘¸ì‹œ ì‹œì‘', { projectId: input.projectId, repo: input.githubRepoUrl });

    try {
      // 1. GitHub ë ˆí¬ì§€í† ë¦¬ ì •ë³´ ì¶”ì¶œ
      const { owner, repo } = this.parseGitHubUrl(input.githubRepoUrl);

      // 2. Octokit ì´ˆê¸°í™”
      const octokit = new Octokit({
        auth: input.githubPat || process.env.GITHUB_PAT,
      });

      // 3. ë ˆí¬ì§€í† ë¦¬ê°€ ì—†ìœ¼ë©´ ìƒì„± (ì¡°ì§ ë˜ëŠ” ê°œì¸ ê³„ì •)
      await this.createRepositoryIfNeeded(octokit, owner, repo, input.projectId);

      // 4. Git ì´ˆê¸°í™”
      await this.initializeGit(input.codeDirectory);

      // 5. ë ˆí¬ì§€í† ë¦¬ ì—°ê²°
      await this.addRemote(input.codeDirectory, input.githubRepoUrl);

      // 6. íŒŒì¼ ì»¤ë°‹
      const filesPushed = await this.commitFiles(input.codeDirectory, input.commitMessage);

      // 7. í‘¸ì‹œ
      const pushResult = await this.pushToGitHub(input.codeDirectory, octokit, owner, repo);

      const output: GitHubPusherOutput = {
        pushResult: {
          commitSha: pushResult.commitSha,
          branch: pushResult.branch,
          repositoryUrl: input.githubRepoUrl,
          filesPushed,
        },
      };

      // 8. ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸
      await this.updateDeployment(input.projectId, output);

      await this.log('GitHub í‘¸ì‹œ ì™„ë£Œ', {
        commitSha: output.pushResult.commitSha,
        filesPushed,
      });

      return {
        status: AgentStatus.COMPLETED,
        output,
      };
    } catch (error: any) {
      await this.logError(error);

      // ì¬ì‹œë„ ì „ëµ
      if (await this.handlePushFailure(input, error)) {
        return this.execute(input);
      }

      return {
        status: AgentStatus.FAILED,
        error: {
          message: error.message,
          stackTrace: error.stack,
          retryable: this.isRetryable(error),
        },
      };
    }
  }

  private parseGitHubUrl(url: string): { owner: string; repo: string } {
    // GitHub URL íŒŒì‹±
    // ì˜ˆ: https://github.com/owner/repo.git
    // ì˜ˆ: git@github.com:owner/repo.git

    const patterns = [
      /https?:\/\/github\.com\/([^\/]+)\/([^\/]+?)(\.git)?$/,
      /git@github\.com:([^\/]+)\/([^\/]+?)(\.git)?$/,
    ];

    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) {
        return { owner: match[1], repo: match[2].replace('.git', '') };
      }
    }

    throw new Error(`Invalid GitHub URL: ${url}`);
  }

  private async initializeGit(cwd: string): Promise<void> {
    // git init
    await execa('git', ['init'], { cwd });

    // git config
    await execa('git', ['config', 'user.name', this.gitConfig.userName], { cwd });
    await execa('git', ['config', 'user.email', this.gitConfig.userEmail], { cwd });
  }

  private async addRemote(cwd: string, url: string): Promise<void> {
    // remoteê°€ ì´ë¯¸ ìˆìœ¼ë©´ ì œê±°
    try {
      await execa('git', ['remote', 'remove', 'origin'], { cwd });
    } catch (error) {
      // remoteê°€ ì—†ìœ¼ë©´ ë¬´ì‹œ
    }

    // remote ì¶”ê°€
    await execa('git', ['remote', 'add', 'origin', url], { cwd });
  }

  private async commitFiles(cwd: string, commitMessage?: string): Promise<number> {
    const message = commitMessage || 'feat: initial MVP generated by MAGIC WAND ğŸª„\n\nCo-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>';

    // git add .
    await execa('git', ['add', '.'], { cwd });

    // git commit
    await execa('git', ['commit', '-m', message], { cwd });

    // íŒŒì¼ ìˆ˜ ì¹´ìš´íŠ¸
    const { stdout } = await execa('git', ['ls-files'], { cwd });
    const files = stdout.trim().split('\n').filter(Boolean);

    return files.length;
  }

  private async pushToGitHub(
    cwd: string,
    octokit: Octokit,
    owner: string,
    repo: string
  ): Promise<{ commitSha: string; branch: string }> {
    const branch = 'main';

    // git push
    await execa('git', ['push', '-u', 'origin', branch], { cwd, timeout: 120000 });

    // ìµœì‹  ì»¤ë°‹ SHA ê°€ì ¸ì˜¤ê¸°
    const { stdout: sha } = await execa('git', ['rev-parse', 'HEAD'], { cwd });

    return {
      commitSha: sha.trim(),
      branch,
    };
  }

  private async createRepositoryIfNeeded(
    octokit: Octokit,
    owner: string,
    repo: string,
    projectId: string
  ): Promise<void> {
    try {
      await this.log('ë ˆí¬ì§€í† ë¦¬ ì¡´ì¬ í™•ì¸', { owner, repo });

      // ë ˆí¬ì§€í† ë¦¬ ì¡´ì¬ í™•ì¸
      try {
        await octokit.rest.repos.get({ owner, repo });
        await this.log('ë ˆí¬ì§€í† ë¦¬ ì´ë¯¸ ì¡´ì¬', { owner, repo });
        return;
      } catch (error: any) {
        if (error.status !== 404) {
          throw error;
        }
        // 404 = ë ˆí¬ì§€í† ë¦¬ ì—†ìŒ, ìƒì„± ì§„í–‰
      }

      await this.log('ë ˆí¬ì§€í† ë¦¬ ìƒì„± ì‹œì‘', { owner, repo });

      // ì¡°ì§(org)ì¸ì§€ ê°œì¸ ì‚¬ìš©ìì¸ì§€ í™•ì¸
      // ownerê°€ orgs/{orgname} í˜•ì‹ì´ë©´ ì¡°ì§
      const isOrg = owner.startsWith('orgs/');
      const orgName = isOrg ? owner.replace('orgs/', '') : owner;

      if (isOrg) {
        // ì¡°ì§ í•˜ìœ„ì— ë ˆí¬ì§€í† ë¦¬ ìƒì„±
        await octokit.rest.repos.createInOrg({
          org: orgName,
          name: repo,
          description: `Generated by MAGIC WAND - Project ${projectId}`,
          private: false,
          auto_init: false,
        });
        await this.log('ì¡°ì§ ë ˆí¬ì§€í† ë¦¬ ìƒì„± ì™„ë£Œ', { org: orgName, repo });
      } else {
        // ê°œì¸ ê³„ì •ì— ë ˆí¬ì§€í† ë¦¬ ìƒì„±
        await octokit.rest.repos.createForAuthenticatedUser({
          name: repo,
          description: `Generated by MAGIC WAND - Project ${projectId}`,
          private: false,
          auto_init: false,
        });
        await this.log('ê°œì¸ ë ˆí¬ì§€í† ë¦¬ ìƒì„± ì™„ë£Œ', { owner, repo });
      }

      // ì ì‹œ ëŒ€ê¸° (GitHubì—ì„œ ë ˆí¬ì§€í† ë¦¬ ì¸ë±ì‹± ëŒ€ê¸°)
      await new Promise(resolve => setTimeout(resolve, 2000));
    } catch (error: any) {
      await this.logError(error);
      throw new Error(`ë ˆí¬ì§€í† ë¦¬ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
    }
  }

  private async handlePushFailure(input: GitHubPusherInput, error: any): Promise<boolean> {
    const errorMessage = error.message || '';

    // ì¸ì¦ ì˜¤ë¥˜
    if (errorMessage.includes('authentication') || errorMessage.includes('401')) {
      await this.log('ì¸ì¦ ì‹¤íŒ¨, PAT í™•ì¸ í•„ìš”', { error: errorMessage });
      return false;
    }

    // ì¶©ëŒ
    if (errorMessage.includes('conflict') || errorMessage.includes('would be overwritten')) {
      await this.log('ì¶©ëŒ ë°œìƒ, ìƒˆ ë¸Œëœì¹˜ ì‹œë„');
      try {
        const newBranch = `magic-wand-${Date.now()}`;
        await execa('git', ['checkout', '-b', newBranch], { cwd: input.codeDirectory });
        await execa('git', ['push', '-u', 'origin', newBranch], { cwd: input.codeDirectory });
        return true;
      } catch (branchError) {
        return false;
      }
    }

    // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ëŠ” ì¬ì‹œë„
    if (this.isRetryable(error)) {
      return true;
    }

    return false;
  }

  private async updateDeployment(projectId: string, output: GitHubPusherOutput): Promise<void> {
    await prisma.deployment.update({
      where: { projectId },
      data: {
        githubRepoUrl: output.pushResult.repositoryUrl,
        githubBranch: output.pushResult.branch,
        status: 'IN_PROGRESS',
      },
    });
  }
}

```markdown
## 파일: src/lib/api/errors.ts

```typescript
/**
 * API 에러 응답을 표준화하고 생성하는 유틸리티 모듈입니다.
 */

export interface ApiErrorResponse {
  success: false;
  error: {
    message: string;
    code: string;
  };
}

export class ApiError extends Error {
  constructor(
    public statusCode: number,
    public code: string,
    message: string
  ) {
    super(message);
    this.name = 'ApiError';
  }

  toJSON(): ApiErrorResponse {
    return {
      success: false,
      error: {
        message: this.message,
        code: this.code,
      },
    };
  }
}

// 주요 HTTP 에러 코드별 팩토리 함수
export const errorHandlers = {
  badRequest: (message: string = '잘못된 요청입니다.') => {
    return new ApiError(400, 'BAD_REQUEST', message);
  },

  unauthorized: (message: string = '인증이 필요합니다.') => {
    return new ApiError(401, 'UNAUTHORIZED', message);
  },

  forbidden: (message: string = '접근이 거부되었습니다.') => {
    return new ApiError(403, 'FORBIDDEN', message);
  },

  notFound: (message: string = '요청한 리소스를 찾을 수 없습니다.') => {
    return new ApiError(404, 'NOT_FOUND', message);
  },

  badGateway: (message: string = '외부 서버 연결에 실패했습니다.') => {
    return new ApiError(502, 'BAD_GATEWAY', message);
  },

  internalServerError: (message: string = '서버 내부 오류가 발생했습니다.') => {
    return new ApiError(500, 'INTERNAL_SERVER_ERROR', message);
  },
};
```

## 파일: src/lib/api/pokemon.ts

```typescript
import { unstable_cache } from 'next/cache';
import { errorHandlers } from './errors';

const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2';

/**
 * PokeAPI에서 포켓몬 리스트를 가져오는 함수
 */
async function fetchPokemonListRaw(offset: number = 0, limit: number = 20) {
  try {
    const response = await fetch(`${POKEAPI_BASE_URL}/pokemon?offset=${offset}&limit=${limit}`);

    if (!response.ok) {
      // PokeAPI가 404나 500 등을 반환한 경우
      if (response.status === 404) {
        throw errorHandlers.notFound('포켓몬 목록을 찾을 수 없습니다.');
      }
      throw errorHandlers.badGateway(`PokeAPI 오류: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    // 네트워크 연결 실패 (DNS 오류, 연결 시간 초과 등)
    if (error instanceof TypeError && error.message.includes('fetch')) {
      throw errorHandlers.badGateway('네트워크 연결 실패. PokeAPI에 접속할 수 없습니다.');
    }
    
    // 이미 ApiError인 경우 그대로 던짐
    if (error instanceof Error && 'statusCode' in error) {
      throw error;
    }

    // 그 외 알 수 없는 에러
    throw errorHandlers.internalServerError('알 수 없는 오류가 발생했습니다.');
  }
}

/**
 * PokeAPI에서 포켓몬 상세 정보를 가져오는 함수
 */
async function fetchPokemonDetailRaw(name: string) {
  try {
    const response = await fetch(`${POKEAPI_BASE_URL}/pokemon/${name}`);

    if (!response.ok) {
      if (response.status === 404) {
        throw errorHandlers.notFound(`"${name}" 포켓몬을 찾을 수 없습니다.`);
      }
      throw errorHandlers.badGateway(`PokeAPI 오류: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    if (error instanceof TypeError && error.message.includes('fetch')) {
      throw errorHandlers.badGateway('네트워크 연결 실패. PokeAPI에 접속할 수 없습니다.');
    }

    if (error instanceof Error && 'statusCode' in error) {
      throw error;
    }

    throw errorHandlers.internalServerError('알 수 없는 오류가 발생했습니다.');
  }
}

// 캐싱 래핑 (에러가 발생해도 적절히 전파되도록 설정)
export const fetchPokemonList = (offset: number = 0, limit: number = 20) =>
  unstable_cache(
    async () => fetchPokemonListRaw(offset, limit),
    ['pokemon-list', offset.toString(), limit.toString()],
    { revalidate: 3600 }
  )();

export const fetchPokemonDetail = (name: string) =>
  unstable_cache(
    async () => fetchPokemonDetailRaw(name),
    ['pokemon-detail', name],
    { revalidate: 3600 }
  )();
```

## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { fetchPokemonList } from '@/lib/api/pokemon';
import { ApiError, errorHandlers } from '@/lib/api/errors';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const offset = parseInt(searchParams.get('offset') || '0');
    const limit = parseInt(searchParams.get('limit') || '20');

    const data = await fetchPokemonList(offset, limit);

    return NextResponse.json({
      success: true,
      data,
    });
  } catch (error) {
    // ApiError 처리 (명시적으로 던져진 에러)
    if (error instanceof ApiError) {
      return NextResponse.json(error.toJSON(), { status: error.statusCode });
    }

    // 예상치 못한 시스템 에러 처리
    console.error('Unexpected Error in /api/pokemon:', error);
    const serverError = errorHandlers.internalServerError();
    
    return NextResponse.json(serverError.toJSON(), { status: 500 });
  }
}
```

## 파일: src/components/ui/error-alert.tsx

```typescript
import React from 'react';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Button } from '@/components/ui/button';
import { AlertCircle, AlertTriangle, Info, RefreshCw } from 'lucide-react';

type ErrorSeverity = 'info' | 'warning' | 'error';

interface ErrorAlertProps {
  error: {
    message: string;
    code?: string;
  };
  severity?: ErrorSeverity;
  onRetry?: () => void;
}

const ErrorIcon = {
  info: Info,
  warning: AlertTriangle,
  error: AlertCircle,
};

const ErrorStyles = {
  info: 'border-blue-500 text-blue-600 bg-blue-50',
  warning: 'border-orange-500 text-orange-600 bg-orange-50',
  error: 'border-red-500 text-red-600 bg-red-50',
};

export const ErrorAlert: React.FC<ErrorAlertProps> = ({
  error,
  severity = 'error',
  onRetry,
}) => {
  const Icon = ErrorIcon[severity];
  const containerStyle = ErrorStyles[severity];

  return (
    <Alert variant="destructive" className={`my-4 ${containerStyle}`}>
      <Icon className="h-4 w-4" />
      <AlertTitle className="font-semibold">
        {severity === 'error' && '오류 발생'}
        {severity === 'warning' && '경고'}
        {severity === 'info' && '알림'}
      </AlertTitle>
      <AlertDescription className="mt-2 flex items-center justify-between">
        <span>{error.message}</span>
        {onRetry && (
          <Button
            variant="outline"
            size="sm"
            onClick={onRetry}
            className="ml-4 border-current hover:bg-current/10"
          >
            <RefreshCw className="mr-2 h-3 w-3" />
            재시도
          </Button>
        )}
      </AlertDescription>
    </Alert>
  );
};
```

## 파일: src/app/page.tsx

```typescript
import React from 'react';
import { fetchPokemonList } from '@/lib/api/pokemon';
import { ErrorAlert } from '@/components/ui/error-alert';
import { ApiError } from '@/lib/api/errors';

export default async function Home() {
  let pokemonData;
  let error: ApiError | null = null;

  try {
    pokemonData = await fetchPokemonList(0, 20);
  } catch (err) {
    // 서버 컴포넌트에서 발생한 에러를 캐치하여 UI에 전달
    if (err instanceof ApiError) {
      error = err;
    } else {
      // 알 수 없는 에러는 일반적인 서버 에러로 처리
      error = new ApiError(500, 'INTERNAL_SERVER_ERROR', '서버 오류가 발생했습니다.');
    }
  }

  // 에러가 발생한 경우 ErrorAlert 렌더링
  if (error) {
    // 502 Bad Gateway (네트워크 오류)는 Warning으로 표시
    const severity = error.statusCode === 502 ? 'warning' : 'error';
    
    return (
      <main className="container mx-auto p-4">
        <h1 className="text-2xl font-bold mb-4">포켓몬 도감</h1>
        <ErrorAlert error={error} severity={severity} />
      </main>
    );
  }

  // 정상 응답 시 리스트 렌더링
  return (
    <main className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">포켓몬 도감</h1>
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
        {pokemonData.results.map((pokemon: any) => (
          <div
            key={pokemon.name}
            className="border rounded-lg p-4 hover:shadow-md transition-shadow bg-white"
          >
            <h2 className="text-lg font-semibold capitalize">{pokemon.name}</h2>
            <p className="text-sm text-gray-500">URL: {pokemon.url}</p>
          </div>
        ))}
      </div>
    </main>
  );
}
```
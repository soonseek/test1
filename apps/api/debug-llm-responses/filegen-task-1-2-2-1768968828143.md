```markdown
## 파일: src/components/pokemon/PokemonCard.tsx

```tsx
import React, { useState } from 'react';
import Image from 'next/image';
import { Skeleton } from '@/components/ui/skeleton';
import { cn } from '@/lib/utils';

interface PokemonCardProps {
  name: string;
  number: string | number;
  imageUrl: string;
  className?: string;
}

export function PokemonCard({ name, number, imageUrl, className }: PokemonCardProps) {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(false);

  // 포켓몬 번호 포맷팅 (예: #001)
  const formattedNumber = typeof number === 'string' ? number : `#${number.toString().padStart(3, '0')}`;

  return (
    <div
      className={cn(
        'group relative flex flex-col items-center justify-center overflow-hidden rounded-xl border bg-card p-4 text-card-foreground shadow transition-all hover:shadow-lg',
        className
      )}
    >
      {/* 이미지 컨테이너: Aspect Ratio 유지 및 Layout Shift 방지 */}
      <div className="relative h-48 w-full overflow-hidden rounded-lg bg-muted/50">
        {isLoading && !error && (
          <Skeleton className="absolute inset-0 z-10 h-full w-full rounded-lg" />
        )}
        
        {error ? (
          <div className="flex h-full items-center justify-center text-muted-foreground text-sm">
            이미지 로드 실패
          </div>
        ) : (
          <Image
            src={imageUrl}
            alt={`${name} 포켓몬 이미지`}
            fill
            sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
            className="object-contain p-4 transition-transform duration-300 group-hover:scale-110"
            onLoad={() => setIsLoading(false)}
            onError={() => {
              setIsLoading(false);
              setError(true);
            }}
            priority={false} // 필요시 true로 변경하여 LCP 최적화
          />
        )}
      </div>

      {/* 포켓몬 정보 영역 */}
      <div className="mt-4 w-full text-center">
        <p className="text-xs font-semibold text-muted-foreground">{formattedNumber}</p>
        <h3 className="text-lg font-bold capitalize text-foreground">{name}</h3>
      </div>
    </div>
  );
}
```

## 파일: src/components/ui/skeleton.tsx

```tsx
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
```

## 파일: src/lib/utils/image.ts

```typescript
/**
 * 이미지 로딩 완료 핸들러 생성 헬퍼
 * @param setIsLoading 로딩 상태를 변경할 setState 함수
 * @returns onLoadingComplete에 전달할 콜백 함수
 */
export const createLoadingHandler = (
  setIsLoading: (loading: boolean) => void
) => {
  return () => {
    setIsLoading(false);
  };
};

/**
 * 이미지 로딩 에러 핸들러 생성 헬퍼
 * @param setIsLoading 로딩 상태를 변경할 setState 함수
 * @param setError 에러 상태를 변경할 setState 함수
 * @returns onError에 전달할 콜백 함수
 */
export const createErrorHandler = (
  setIsLoading: (loading: boolean) => void,
  setError: (error: boolean) => void
) => {
  return () => {
    setIsLoading(false);
    setError(true);
  };
};

/**
 * (선택 사항) BlurDataURL을 생성하는 함수
 * 현재 구현에서는 Skeleton UI를 사용하므로 직접적으로 사용되지 않으나,
 * placeholder="blur"를 사용할 경우를 위해 유틸리티로 남겨둡니다.
 * 
 * 참고: 실제 BlurDataURL을 생성하려면 이미지를 다운로드하여 블러 처리 후
 * Base64로 인코딩하는 과정이 필요하며, 이는 빌드 타임이나 서버 사이드에서
 * 수행하는 것이 성능상 유리합니다.
 */
export async function getBlurDataURL(url: string): Promise<string> {
  // 클라이언트 사이드에서 간단한 플레이스홀더를 반환하거나
  // 별도의 이미지 프로세싱 라이브러리(jimp, sharp 등)를 통해 구현합니다.
  // 여기서는 빈 문자열을 반환하여 기본 동작만 정의합니다.
  return '';
}
```

## 파일: next.config.mjs

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'raw.githubusercontent.com',
        pathname: '/PokeAPI/sprites/**',
      },
      // 필요시 다른 포켓몬 관련 이미지 도메인 추가 가능
      // {
      //   protocol: 'https',
      //   hostname: 'img.pokemondb.net',
      // },
    ],
  },
};

export default nextConfig;
```
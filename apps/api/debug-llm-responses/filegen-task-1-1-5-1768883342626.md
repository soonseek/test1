```markdown
## 파일: src/types/pokemon.ts

```typescript
/**
 * PokeAPI 원본 응답 형태 (리스트 항목)
 */
export interface PokeApiListItem {
  name: string;
  url: string;
}

/**
 * PokeAPI 원본 전체 응답 형태
 */
export interface PokeApiListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokeApiListItem[];
}

/**
 * 클라이언트에 반환할 최종 형태 (ID 추출됨)
 */
export interface PokemonListItem {
  id: number;
  name: string;
}

/**
 * API 라우트의 최종 응답 형태
 */
export interface PokemonListResponse {
  results: PokemonListItem[];
  count: number;
  next?: string | null;
}
```

## 파일: src/lib/api/pokeapi.ts

```typescript
import { PokeApiListResponse, PokemonListItem } from '@/types/pokemon';

const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2';

/**
 * PokeAPI의 pokemon 엔드포인트를 호출하여 데이터를 가져옵니다.
 * Next.js 내장 fetch를 사용하며 기본 캐싱 전략을 따릅니다.
 * 
 * @param offset 건너뛸 데이터 수
 * @param limit 가져올 데이터 수
 * @returns 변환된 포켓몬 리스트
 */
export async function fetchPokemonList(
  offset: number = 0,
  limit: number = 20
): Promise<{ results: PokemonListItem[]; count: number; next: string | null }> {
  try {
    const url = `${POKEAPI_BASE_URL}/pokemon?offset=${offset}&limit=${limit}`;
    
    // Next.js fetch: 기본적으로 force-cache이며, ISR과 유사하게 동작할 수 있습니다.
    const response = await fetch(url, {
      // 서버 컴포넌트 및 라우트에서 데이터 가져오기를 위한 설정
      next: { revalidate: 3600 }, // 1시간마다 재검증
    });

    if (!response.ok) {
      throw new Error(`PokeAPI fetch failed: ${response.statusText}`);
    }

    const data: PokeApiListResponse = await response.json();

    // URL에서 ID 추출 및 매핑 로직
    // URL 예시: https://pokeapi.co/api/v2/pokemon/1/
    const transformedResults: PokemonListItem[] = data.results.map((item) => {
      const urlParts = item.url.split('/').filter(Boolean);
      const id = Number(urlParts[urlParts.length - 1]); // URL의 마지막 부분이 ID

      return {
        id,
        name: item.name,
      };
    });

    return {
      results: transformedResults,
      count: data.count,
      next: data.next,
    };
  } catch (error) {
    console.error('Error in fetchPokemonList:', error);
    throw error; // 호출한 라우트 핸들러로 에러 전파
  }
}
```

## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { fetchPokemonList } from '@/lib/api/pokeapi';
import { handleApiError } from './error';

/**
 * GET /api/pokemon
 * 포켓몬 리스트를 반환하는 API 핸들러
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // 쿼리 파라미터 파싱 및 검증
    const rawOffset = searchParams.get('offset');
    const rawLimit = searchParams.get('limit');

    const offset = rawOffset ? parseInt(rawOffset, 10) : 0;
    const limit = rawLimit ? parseInt(rawLimit, 10) : 20;

    if (isNaN(offset) || isNaN(limit) || offset < 0 || limit < 1) {
      return handleApiError(400, 'Invalid offset or limit parameters');
    }

    // 데이터 가져오기
    const data = await fetchPokemonList(offset, limit);

    // Next.js Response 객체 반환 (헤더 설정 포함)
    return NextResponse.json(data, {
      status: 200,
      headers: {
        'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400',
      },
    });
  } catch (error) {
    console.error('API Route Error:', error);
    return handleApiError(500, 'Internal Server Error');
  }
}
```

## 파일: src/app/api/pokemon/error.ts

```typescript
import { NextResponse } from 'next/server';

export interface ApiErrorResponse {
  error: string;
  message: string;
}

/**
 * API 라우트에서 발생하는 에러를 표준화하여 응답을 생성합니다.
 * 
 * @param status HTTP 상태 코드
 * @param message 에러 메시지
 * @returns NextResponse JSON 객체
 */
export function handleApiError(status: number, message: string) {
  const errorResponse: ApiErrorResponse = {
    error: status === 500 ? 'Internal Server Error' : 'Bad Request',
    message,
  };

  return NextResponse.json(errorResponse, {
    status,
    headers: {
      'Cache-Control': 'no-store', // 에러 응답은 캐싱하지 않음
    },
  });
}
```
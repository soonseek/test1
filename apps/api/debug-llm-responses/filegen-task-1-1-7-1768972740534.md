```markdown
## 파일: src/types/pokemon.ts

```typescript
/**
 * PokeAPI v2 pokemon 리스트 엔드포인트의 원본 응답 형태
 */
export interface PokeAPIListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokeAPIResource[];
}

/**
 * PokeAPI results 배열 내부의 객체 형태
 */
export interface PokeAPIResource {
  name: string;
  url: string;
}

/**
 * 클라이언트로 반환할 최종 데이터 형태
 * URL에서 ID를 추출하여 포함
 */
export interface PokemonListItem {
  id: number;
  name: string;
  url: string;
}

/**
 * 유틸리티 함수 타입: URL에서 ID 추출
 */
export type UrlToIdFn = (url: string) => number;
```

## 파일: src/lib/api/pokemon.ts

```typescript
import { PokeAPIListResponse, PokemonListItem } from '@/types/pokemon';

const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2';

/**
 * PokeAPI의 URL에서 ID를 추출하는 유틸리티 함수
 * 예: https://pokeapi.co/api/v2/pokemon/1/ -> 1
 */
function urlToId(url: string): number {
  const parts = url.split('/').filter(Boolean);
  const idStr = parts[parts.length - 1];
  return parseInt(idStr, 10);
}

/**
 * PokeAPI 외부 호출을 담당하는 서버 사이드 함수
 * @param limit 가져올 아이템 개수
 * @param offset 시작 위치
 * @returns 매핑된 PokemonListItem 배열
 */
export async function fetchPokemonList(
  limit: number = 20,
  offset: number = 0
): Promise<PokemonListItem[]> {
  try {
    const searchParams = new URLSearchParams({
      limit: limit.toString(),
      offset: offset.toString(),
    });

    // Next.js 내장 fetch 사용 (캐싱 전략: force-no-store 또는 기본 캐시 사용 가능)
    // 여기서는 데이터 변경이 자주 없으므로 기본 캐시를 허용하되, 
    // 필요시 'no-store'를 사용하여 항상 최신 데이터를 가져옵니다.
    const response = await fetch(`${POKEAPI_BASE_URL}/pokemon?${searchParams}`, {
      // next: { revalidate: 3600 } // ISR 방식으로 캐싱하고 싶다면 사용
    });

    if (!response.ok) {
      throw new Error(`PokeAPI fetch failed: ${response.status} ${response.statusText}`);
    }

    const data: PokeAPIListResponse = await response.json();

    // 데이터 매핑: PokeAPIResource -> PokemonListItem
    const mappedData: PokemonListItem[] = data.results.map((item) => ({
      id: urlToId(item.url),
      name: item.name,
      url: item.url,
    }));

    return mappedData;
  } catch (error) {
    console.error('Error in fetchPokemonList:', error);
    throw error; // API Route에서 처리할 수 있도록 Error throw
  }
}
```

## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { fetchPokemonList } from '@/lib/api/pokemon';

/**
 * GET /api/pokemon
 * 포켓몬 리스트를 반환하는 API 핸들러
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // 쿼리 파라미터 파싱 및 기본값 설정
    const limit = parseInt(searchParams.get('limit') || '20', 10);
    const offset = parseInt(searchParams.get('offset') || '0', 10);

    // 유효성 검증 (간단한 범위 체크)
    if (limit < 1 || limit > 100) {
      return NextResponse.json(
        { error: 'Limit must be between 1 and 100' },
        { status: 400 }
      );
    }

    if (offset < 0) {
      return NextResponse.json(
        { error: 'Offset cannot be negative' },
        { status: 400 }
      );
    }

    // 데이터 페칭
    const data = await fetchPokemonList(limit, offset);

    // 성공 응답 반환
    return NextResponse.json(data, {
      status: 200,
      headers: {
        // CORS 헤더 설정 (필요시)
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type',
      },
    });
  } catch (error) {
    // 에러 처리
    console.error('API Route Error:', error);
    
    const errorMessage = error instanceof Error ? error.message : 'Unknown Server Error';
    
    return NextResponse.json(
      { error: errorMessage },
      { status: 500 }
    );
  }
}

// OPTIONS 메서드 핸들러 (Preflight 요청 대응)
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    },
  });
}
```

## 파일: src/app/api/pokemon/route.test.ts

```typescript
import { GET } from './route';
import { fetchPokemonList } from '@/lib/api/pokemon';
import { NextRequest } from 'next/server';

// Mock 모듈 설정
jest.mock('@/lib/api/pokemon', () => ({
  fetchPokemonList: jest.fn(),
}));

describe('/api/pokemon Route', () => {
  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should return 200 and a list of Pokemon when fetchPokemonList succeeds', async () => {
    // Mock 데이터 설정
    const mockPokemonList = [
      { id: 1, name: 'bulbasaur', url: 'https://pokeapi.co/api/v2/pokemon/1/' },
      { id: 2, name: 'ivysaur', url: 'https://pokeapi.co/api/v2/pokemon/2/' },
    ];
    (fetchPokemonList as jest.Mock).mockResolvedValue(mockPokemonList);

    // 가상의 Request 객체 생성
    const request = new NextRequest(new URL('http://localhost:3000/api/pokemon?limit=2&offset=0'));

    // 핸들러 실행
    const response = await GET(request);
    const json = await response.json();

    // 검증
    expect(response.status).toBe(200);
    expect(json).toEqual(mockPokemonList);
    expect(fetchPokemonList).toHaveBeenCalledWith(2, 0);
  });

  it('should return 500 when fetchPokemonList throws an error', async () => {
    // Mock 에러 설정
    (fetchPokemonList as jest.Mock).mockRejectedValue(new Error('Network Error'));

    const request = new NextRequest(new URL('http://localhost:3000/api/pokemon'));
    const response = await GET(request);
    const json = await response.json();

    expect(response.status).toBe(500);
    expect(json).toHaveProperty('error');
  });

  it('should parse limit and offset query parameters correctly', async () => {
    (fetchPokemonList as jest.Mock).mockResolvedValue([]);

    const request = new NextRequest(new URL('http://localhost:3000/api/pokemon?limit=50&offset=10'));
    await GET(request);

    expect(fetchPokemonList).toHaveBeenCalledWith(50, 10);
  });

  it('should use default values if query parameters are missing', async () => {
    (fetchPokemonList as jest.Mock).mockResolvedValue([]);

    const request = new NextRequest(new URL('http://localhost:3000/api/pokemon'));
    await GET(request);

    expect(fetchPokemonList).toHaveBeenCalledWith(20, 0);
  });
});
```

## 파일: README_TESTING.md

```markdown
# API 테스트 가이드

이 문서는 `/api/pokemon` 엔드포인트의 로컬 테스트 및 데이터 검증 방법을 안내합니다.

## 1. 브라우저 테스트

가장 간단한 방법으로 브라우저 주소창을 이용합니다.

1. 개발 서버를 실행합니다 (`npm run dev`).
2. 아래 URL을 접속합니다:
   ```
   http://localhost:3000/api/pokemon
   ```
3. **예상 결과**: 브라우저 화면에 JSON 형식의 포켓몬 리스트가 출력되어야 합니다.
   ```json
   [
     {
       "id": 1,
       "name": "bulbasaur",
       "url": "https://pokeapi.co/api/v2/pokemon/1/"
     },
     ...
   ]
   ```

## 2. Postman 또는 cURL 테스트

쿼리 파라미터와 상태 코드를 정확히 검증하기 위해 권장하는 방법입니다.

### cURL 명령어

```bash
curl -X GET "http://localhost:3000/api/pokemon?limit=10&offset=0"
```

### Postman 설정

- **Method**: `GET`
- **URL**: `http://localhost:3000/api/pokemon`
- **Params** (Key | Value):
  - `limit` | `10`
  - `offset` | `0`

## 3. 검증 항목 (Checklist)

테스트 수행 시 다음 사항을 확인하세요:

1. **HTTP 상태 코드**: 응답이 `200 OK` 여야 합니다.
2. **JSON 구조**:
   - 응답 본문이 유효한 JSON 배열이어야 합니다.
   - 각 객체는 `id` (number), `name` (string), `url` (string) 속성을 포함해야 합니다. (`src/types/pokemon.ts`의 `PokemonListItem` 인터페이스 준수)
3. **데이터 매핑**:
   - `id` 값이 URL에서 올바르게 추출된 정수여야 합니다 (예: URL 끝이 `/1/`이면 ID는 1).
4. **에러 처리**:
   - 잘못된 파라미터(예: `limit=-1`)를 보냈을 때 `400 Bad Request` 또는 적절한 에러 메시지가 반환되는지 확인합니다.
```
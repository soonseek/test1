```markdown
## 파일: src/types/pokemon.ts

```typescript
/**
 * 포켓몬 타입 열거형 (PokeAPI 기준)
 */
export type PokemonType =
  | "normal"
  | "fire"
  | "water"
  | "grass"
  | "electric"
  | "ice"
  | "fighting"
  | "poison"
  | "ground"
  | "flying"
  | "psychic"
  | "bug"
  | "rock"
  | "ghost"
  | "dragon"
  | "dark"
  | "steel"
  | "fairy";

/**
 * 내부 도메인 모델: 클라이언트에서 사용할 포켓몬 상세 정보
 */
export interface Pokemon {
  id: number;
  name: string;
  url: string; // 상세 조회를 위한 URL 또는 ID 추출용
  types?: PokemonType[]; // 상세 조회 시 확장 가능
  imageUrl?: string; // 공식 아트워크 등
}

/**
 * 내부 도메인 모델: 리스트 응답 형식
 */
export interface PokemonList {
  count: number;
  results: Pokemon[];
  next?: string | null;
  previous?: string | null;
}

/**
 * PokeAPI v2 Raw Response 타입 (API 래퍼에서 사용)
 */
export interface PokemonListItemRaw {
  name: string;
  url: string;
}

export interface PokemonListResponseRaw {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokemonListItemRaw[];
}
```

## 파일: src/lib/utils/validation.ts

```typescript
/**
 * API Route 핸들러에서 사용할 입력값 검증 유틸리티
 */

export interface PaginationParams {
  offset: number;
  limit: number;
}

export class ValidationError extends Error {
  public statusCode: number;
  constructor(message: string, statusCode: number = 400) {
    super(message);
    this.name = "ValidationError";
    this.statusCode = statusCode;
  }
}

/**
 * 쿼리 파라미터를 검증하고 기본값을 적용합니다.
 * @param offset 시작 위치
 * @param limit 가져올 개수
 * @returns 검증된 파라미터 객체
 * @throws ValidationError 유효하지 않은 범위의 값이 들어온 경우
 */
export function validateAndParseParams(
  offset?: string | string[],
  limit?: string | string[]
): PaginationParams {
  const parsedOffset = parseInt(Array.isArray(offset) ? offset[0] : offset || "0", 10);
  const parsedLimit = parseInt(Array.isArray(limit) ? limit[0] : limit || "20", 10);

  // NaN 체크
  if (isNaN(parsedOffset) || isNaN(parsedLimit)) {
    throw new ValidationError("Offset and Limit must be valid numbers.");
  }

  // 범위 체크 (PokeAPI 제한 및 성능 고려)
  if (parsedOffset < 0) {
    throw new ValidationError("Offset cannot be negative.");
  }
  if (parsedLimit < 1 || parsedLimit > 100) {
    throw new ValidationError("Limit must be between 1 and 100.");
  }

  return {
    offset: parsedOffset,
    limit: parsedLimit,
  };
}
```

## 파일: src/lib/api/pokemon.ts

```typescript
import { PokemonListResponseRaw, PokemonList } from "@/types/pokemon";

const POKEAPI_BASE_URL = "https://pokeapi.co/api/v2";

/**
 * PokeAPI v2 엔드포인트와 통신하는 클라이언트 래퍼
 * Next.js fetch 확장 옵션을 사용하여 서버 사이드 캐싱을 적용합니다.
 */
export async function fetchPokemonList(
  offset: number = 0,
  limit: number = 20
): Promise<PokemonList> {
  const url = `${POKEAPI_BASE_URL}/pokemon?offset=${offset}&limit=${limit}`;

  try {
    // Next.js의 fetch 확장: next.revalidate 옵션을 사용하여
    // 서버(데이터 소스) 요청 자체를 60초 동안 캐싱합니다.
    const response = await fetch(url, {
      next: { revalidate: 60 },
    });

    if (!response.ok) {
      throw new Error(`PokeAPI fetch failed: ${response.status} ${response.statusText}`);
    }

    const data: PokemonListResponseRaw = await response.json();

    // 내부 도메인 모델 형태로 매핑 (현재 구조는 동일하나, 명시적 매핑)
    return {
      count: data.count,
      next: data.next,
      previous: data.previous,
      results: data.results.map((item) => ({
        name: item.name,
        url: item.url,
        // ID 추출 로직이 필요할 경우 여기서 처리 (예: url.split('/').filter(Boolean).pop())
        id: parseInt(item.url.split("/").filter(Boolean).pop() || "0", 10),
      })),
    };
  } catch (error) {
    // 네트워크 에러 또는 파싱 에러 처리
    console.error("Error fetching from PokeAPI:", error);
    throw new Error("Failed to fetch pokemon data. Please try again later.");
  }
}
```

## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextRequest, NextResponse } from "next/server";
import { fetchPokemonList } from "@/lib/api/pokemon";
import { validateAndParseParams, ValidationError } from "@/lib/utils/validation";

/**
 * Next.js API Route Handler
 * 클라이언트 요청을 프록시하고 Cache-Control 헤더를 설정하여
 * 브라우저 및 CDN(Netlify) 캐싱을 유도합니다.
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const offset = searchParams.get("offset");
    const limit = searchParams.get("limit");

    // 1. 입력값 검증
    const { offset: validOffset, limit: validLimit } = validateAndParseParams(offset, limit);

    // 2. 데이터 패칭 (내부적으로 fetch 캐싱 적용됨)
    const data = await fetchPokemonList(validOffset, validLimit);

    // 3. 응답 반환 및 캐싱 전략 적용
    // Cache-Control 헤더를 통해 CDN 및 브라우저 캐싱 정책 설정
    const response = NextResponse.json(data, {
      status: 200,
      headers: {
        "Cache-Control": "public, s-maxage=60, stale-while-revalidate=30",
      },
    });

    return response;
  } catch (error) {
    // 에러 처리
    if (error instanceof ValidationError) {
      return NextResponse.json(
        { message: error.message },
        { status: error.statusCode }
      );
    }

    return NextResponse.json(
      { message: "Internal Server Error" },
      { status: 500 }
    );
  }
}

// 선택 사항: Route Segment Config를 통한 ISR 설정
// export const revalidate = 60; // 이 페이지 세그먼트 자체의 재검증 시간 설정
```
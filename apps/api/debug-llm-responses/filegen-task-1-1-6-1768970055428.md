```markdown
## 파일: src/types/error.ts

```typescript
/**
 * 에러 코드 Enum
 */
export enum ErrorCode {
  NETWORK_ERROR = 'NETWORK_ERROR',
  PARSE_ERROR = 'PARSE_ERROR',
  UPSTREAM_ERROR = 'UPSTREAM_ERROR',
  INTERNAL_ERROR = 'INTERNAL_ERROR',
}

/**
 * PokeAPI 관련 커스텀 에러 클래스
 */
export class PokeApiError extends Error {
  public readonly code: ErrorCode;
  public readonly statusCode: number;
  public readonly details?: string;

  constructor(message: string, code: ErrorCode, statusCode: number, details?: string) {
    super(message);
    this.name = 'PokeApiError';
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
  }
}

/**
 * API 응답용 에러 DTO 인터페이스
 */
export interface ApiErrorResponse {
  error: {
    message: string;
    code: ErrorCode;
    statusCode: number;
    details?: string;
  };
}
```

## 파일: src/lib/api/pokemon.ts

```typescript
import { PokeApiError, ErrorCode } from '@/types/error';

const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2';

export interface PokemonListItem {
  id: number;
  name: string;
  url: string;
  image: string;
}

export interface PokemonListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokemonListItem[];
}

/**
 * PokeAPI에서 포켓몬 목록을 가져오는 함수
 * 에러 핸들링 및 재시도 로직을 포함합니다.
 */
export async function fetchPokemonList(limit: number = 20, offset: number = 0): Promise<PokemonListResponse> {
  const url = `${POKEAPI_BASE_URL}/pokemon?limit=${limit}&offset=${offset}`;

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10초 타임아웃

    const response = await fetch(url, {
      next: { revalidate: 60 }, // 60초 동안 데이터 캐싱
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      // PokeAPI가 5xx 에러를 반환한 경우
      if (response.status >= 500) {
        throw new PokeApiError(
          'Upstream server error',
          ErrorCode.UPSTREAM_ERROR,
          502,
          `PokeAPI returned ${response.status}`
        );
      }
      // 기타 HTTP 에러
      throw new PokeApiError(
        'Failed to fetch data',
        ErrorCode.NETWORK_ERROR,
        502,
        `Status: ${response.status}`
      );
    }

    // 데이터 파싱 시도
    let data: any;
    try {
      data = await response.json();
    } catch (parseError) {
      throw new PokeApiError(
        'Failed to parse API response',
        ErrorCode.PARSE_ERROR,
        502,
        parseError instanceof Error ? parseError.message : 'Unknown parse error'
      );
    }

    // 데이터 가공 (이미지 URL 생성 등)
    const processedResults = data.results.map((item: { name: string; url: string }, index: number) => {
      const id = offset + index + 1;
      return {
        id,
        name: item.name,
        url: item.url,
        image: `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${id}.png`,
      };
    });

    return {
      count: data.count,
      next: data.next,
      previous: data.previous,
      results: processedResults,
    };

  } catch (error) {
    // 네트워크 에러 또는 타임아웃 (AbortError)
    if (error instanceof PokeApiError) {
      throw error;
    }

    if (error instanceof Error) {
      if (error.name === 'AbortError') {
        throw new PokeApiError(
          'Request timeout',
          ErrorCode.NETWORK_ERROR,
          504,
          'Request took too long to respond'
        );
      }
      throw new PokeApiError(
        'Network connection failed',
        ErrorCode.NETWORK_ERROR,
        502,
        error.message
      );
    }

    // 예상치 못한 에러
    throw new PokeApiError(
      'An unexpected error occurred',
      ErrorCode.INTERNAL_ERROR,
      500,
      'Unknown error'
    );
  }
}
```

## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextResponse } from 'next/server';
import { fetchPokemonList } from '@/lib/api/pokemon';
import { PokeApiError, ErrorCode, ApiErrorResponse } from '@/types/error';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const limit = Number(searchParams.get('limit')) || 20;
  const offset = Number(searchParams.get('offset')) || 0;

  try {
    const data = await fetchPokemonList(limit, offset);
    return NextResponse.json(data, { status: 200 });
  } catch (error) {
    console.error('[API Route Error]', error);

    // PokeApiError 처리 (명시적인 에러)
    if (error instanceof PokeApiError) {
      const errorResponse: ApiErrorResponse = {
        error: {
          message: error.message,
          code: error.code,
          statusCode: error.statusCode,
          details: error.details,
        },
      };
      return NextResponse.json(errorResponse, { status: error.statusCode });
    }

    // 기타 에러 처리 (500 Internal Server Error)
    const errorResponse: ApiErrorResponse = {
      error: {
        message: 'Internal Server Error',
        code: ErrorCode.INTERNAL_ERROR,
        statusCode: 500,
        details: error instanceof Error ? error.message : 'Unknown server error',
      },
    };
    return NextResponse.json(errorResponse, { status: 500 });
  }
}
```

## 파일: src/app/error.tsx

```tsx
'use client';

import { useEffect } from 'react';
import { ErrorCode } from '@/types/error';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    // 에러 로깅 서비스로 전송 (예: Sentry)
    console.error('Global Error Boundary:', error);
  }, [error]);

  // 에러 메시지 파싱 (커스텀 에러 메시지가 있는 경우 사용)
  const getErrorMessage = () => {
    try {
      // 에러 객체 내에 JSON 형태로 묻어있는 경우 처리 (선택 사항)
      if (error.message.includes('Upstream server error')) {
        return '외부 데이터 서버에 연결할 수 없습니다.';
      }
      if (error.message.includes('Network connection failed')) {
        return '네트워크 연결을 확인해주세요.';
      }
    } catch (e) {
      // 무시
    }
    return '데이터를 가져오는 중 문제가 발생했습니다.';
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-50 text-gray-900 p-4">
      <div className="max-w-md w-full bg-white shadow-lg rounded-lg p-8 text-center space-y-6">
        <div className="flex justify-center">
          <div className="rounded-full bg-red-100 p-4">
            <svg
              className="h-10 w-10 text-red-600"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              />
            </svg>
          </div>
        </div>

        <div className="space-y-2">
          <h2 className="text-2xl font-bold text-gray-900">오류 발생</h2>
          <p className="text-gray-600">{getErrorMessage()}</p>
          {process.env.NODE_ENV === 'development' && (
            <p className="text-xs text-gray-400 mt-2 break-all">{error.message}</p>
          )}
        </div>

        <div className="flex flex-col sm:flex-row gap-3 justify-center">
          <button
            onClick={reset}
            className="inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors"
          >
            다시 시도
          </button>
          <button
            onClick={() => (window.location.href = '/')}
            className="inline-flex items-center justify-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors"
          >
            홈으로 이동
          </button>
        </div>
      </div>
    </div>
  );
}
```
작업을 시작하겠습니다.

이 Task는 `getPokemonList` 함수에 **DB 캐싱 로직(Cache-Aside Pattern)**을 통합하는 작업입니다.

**구현 전략:**
1.  **Prisma Client**를 사용하여 `PokemonCache` 테이블을 조회합니다.
2.  데이터가 존재하면 DB 데이터를 반환합니다.
3.  데이터가 없으면 PokeAPI를 호출합니다.
4.  API 호출 결과를 DB에 저장(Upsert)한 후 반환합니다.
5.  이 로직을 `src/lib/api/pokemon.ts`에 구현합니다.

**주의사항:**
- 프로젝트 구조가 단일 앱(Standard Next.js)이므로 `apps/web` 또는 `apps/api` 경로를 사용하지 않고, **루트의 `src`** 디렉토리를 기준으로 파일을 생성합니다.

생성할 파일 목록:
1.  `src/lib/prisma.ts`: Prisma Client 싱글톤 인스턴스 (DB 연결)
2.  `src/lib/api/pokemon.ts`: 캐싱 로직이 포함된 페칭 함수
3.  `src/types/pokemon.ts`: 타입 정의

---

## 파일: src/lib/prisma.ts

```typescript
import { PrismaClient } from '@/prisma/client'; // prisma 생성 경로 (보통 @/prisma/client 또는 @prisma/client)

// PrismaClient는 개발 환경(HMR)에서 핫 리로딩 시 연결이 중복되는 것을 막기 위해
// 전역 변수에 인스턴스를 캐싱합니다.
const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

## 파일: src/types/pokemon.ts

```typescript
// PokeAPI 응답 타입 정의

export interface PokemonListItem {
  name: string;
  url: string;
}

export interface PokemonListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokemonListItem[];
}

// DB 캐시 데이터 형태 (JSON 필드에 저장될 구조)
export interface CachedPokemonListData {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokemonListItem[];
  cachedAt: string; // 캐시 유효성 확인용
}
```

## 파일: src/lib/api/pokemon.ts

```typescript
'use server';

import { prisma } from '@/lib/prisma';
import { PokemonListResponse, CachedPokemonListData } from '@/types/pokemon';

const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2';

/**
 * 포켓몬 목록을 가져오는 함수입니다.
 * DB 캐싱 전략(Cache-Aside)을 사용합니다.
 * 
 * 1. DB 조회 (PokemonCache 테이블)
 * 2. 데이터가 있고 유효하면 반환
 * 3. 없으면 PokeAPI 호출
 * 4. API 결과를 DB에 저장 후 반환
 */
export async function getPokemonList(offset = 0, limit = 20): Promise<PokemonListResponse> {
  const cacheKey = `pokemon-list-${offset}-${limit}`;
  const CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24시간 캐시 유효기간 (선택 사항)

  try {
    // 1. DB 캐시 조회 시도
    const cachedRecord = await prisma.pokemonCache.findUnique({
      where: { id: cacheKey },
    });

    // 2. 캐시 히트 확인 및 유효성 검사
    if (cachedRecord) {
      const cachedData = cachedRecord.data as CachedPokemonListData;
      const now = new Date().getTime();
      const cachedTime = new Date(cachedRecord.updatedAt).getTime();

      // 캐시가 유효한 경우 (TTL 내에 있거나, TTL 설정을 안 했을 경우)
      // 여기서는 단순화를 위해 데이터가 존재하면 반환하지만, 필요시 TTL 로직 추가 가능
      if (now - cachedTime < CACHE_TTL_MS) {
        console.log(`[Cache Hit] Key: ${cacheKey}`);
        return {
          count: cachedData.count,
          next: cachedData.next,
          previous: cachedData.previous,
          results: cachedData.results,
        };
      } else {
        console.log(`[Cache Stale] Key: ${cacheKey}, Refetching...`);
      }
    }

    // 3. 캐시 미스 또는 만료 시 PokeAPI 호출
    console.log(`[Cache Miss] Fetching from PokeAPI...`);
    const response = await fetch(`${POKEAPI_BASE_URL}/pokemon?offset=${offset}&limit=${limit}`);
    
    if (!response.ok) {
      throw new Error(`PokeAPI fetch failed: ${response.statusText}`);
    }

    const data: PokemonListResponse = await response.json();

    // 4. DB에 캐시 저장 (Upsert)
    // Prisma Json 타입을 사용하여 데이터를 저장합니다.
    await prisma.pokemonCache.upsert({
      where: { id: cacheKey },
      update: {
        data: data as any, // Prisma JsonValue 타입 호환
        updatedAt: new Date(),
      },
      create: {
        id: cacheKey,
        data: data as any, // Prisma JsonValue 타입 호환
      },
    });

    console.log(`[Cache Saved] Key: ${cacheKey}`);
    return data;

  } catch (error) {
    console.error('Error fetching Pokemon list:', error);
    
    // 에러 발생 시, 이전 캐시가 있다면 "오래된 데이터"라도 반환하는 장애 복구 전략 (Fallback)
    if (cachedRecord) {
      console.warn('[Fallback] Returning stale cache due to API error');
      const cachedData = cachedRecord.data as CachedPokemonListData;
      return {
        count: cachedData.count,
        next: cachedData.next,
        previous: cachedData.previous,
        results: cachedData.results,
      };
    }

    throw error;
  }
}
```

### 추가 설명

1.  **`src/lib/prisma.ts`**: Next.js Serverless 환경(또는 App Router)에서는 개발 중 핫 리로딩이 발생할 때마다 DB 연결이 계속 쌓일 수 있습니다. 이를 방지하기 위해 전역 변수(`globalForPrisma`)를 사용하여 Prisma Client 인스턴스를 재사용하는 표준 패턴을 적용했습니다.
2.  **`src/lib/api/pokemon.ts`**:
    *   **Cache-Aside 패턴 구현**: 먼저 DB(`PokemonCache`)를 조회하고, 데이터가 없을 때만 외부 API(`PokeAPI`)를 요청합니다.
    *   **Upsert**: `prisma.pokemonCache.upsert`를 사용하여 데이터가 있으면 업데이트(`updatedAt` 갱신), 없으면 생성(`create`)하도록 했습니다. 이를 통해 ID 충돌 없이 데이터를 갱신할 수 있습니다.
    *   **Fallback (장애 복구)**: 만약 PokeAPI가 다운되었을 경우, DB에 남아있는 (약간 오래되었을 수 있는) 캐시 데이터를 반환하여 서비스가 완전히 중단되는 것을 방지하는 로직을 추가했습니다.
    *   **JSON 타입 처리**: Prisma의 `Json` 필드에 데이터를 넣기 위해 `as any`를 사용했지만, 실제 프로젝트에서는 Prisma Schema의 `Json` 타입 정의에 따라 타입이 자동으로 추론될 수 있습니다.

이 코드는 Task `task-1-1-6`의 요구사항인 "DB 캐싱 로직 페칭 함수에 통합"을 충족합니다.
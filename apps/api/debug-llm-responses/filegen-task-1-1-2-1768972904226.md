```markdown
## 파일: src/types/pokemon.ts

```typescript
/**
 * PokeAPI 리스트 응답 내부의 개별 아이템 형태
 */
export interface PokeApiListItem {
  name: string;
  url: string;
}

/**
 * PokeAPI pokemon 리스트 엔드포인트의 전체 응답 형태
 */
export interface PokeApiListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokeApiListItem[];
}

/**
 * 애플리케이션에서 사용하는 표준화된 포켓몬 아이템 형태
 * API 응답의 URL에서 ID를 추출하여 포함합니다.
 */
export interface PokemonListItem {
  id: number;
  name: string;
  url: string;
}
```

## 파일: src/lib/constants/api.ts

```typescript
export const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2';
export const DEFAULT_FETCH_LIMIT = 20;
```

## 파일: src/lib/utils/validation.ts

```typescript
import { PokeApiListResponse } from '@/types/pokemon';

/**
 * PokeAPI 리스트 응답 데이터의 구조를 런타임에 검증하는 타입 가드 함수
 * @param data 검증할 unknown 데이터
 * @returns 데이터가 유효한 PokeApiListResponse 형태이면 true, 아니면 false
 */
export function validatePokemonList(data: unknown): data is PokeApiListResponse {
  if (typeof data !== 'object' || data === null) {
    return false;
  }

  const obj = data as Record<string, unknown>;

  // 최상위 필드 검증
  if (
    typeof obj.count !== 'number' ||
    (obj.next !== null && typeof obj.next !== 'string') ||
    (obj.previous !== null && typeof obj.previous !== 'string') ||
    !Array.isArray(obj.results)
  ) {
    return false;
  }

  // results 배열 내부 항목 검증
  for (const item of obj.results) {
    if (
      typeof item !== 'object' ||
      item === null ||
      typeof (item as Record<string, unknown>).name !== 'string' ||
      typeof (item as Record<string, unknown>).url !== 'string'
    ) {
      return false;
    }
  }

  return true;
}
```

## 파일: src/lib/api/pokeapi.ts

```typescript
import { PokeApiListResponse, PokemonListItem } from '@/types/pokemon';
import { POKEAPI_BASE_URL, DEFAULT_FETCH_LIMIT } from '@/lib/constants/api';
import { validatePokemonList } from '@/lib/utils/validation';

/**
 * URL에서 ID를 추출하는 헬퍼 함수
 * 예: https://pokeapi.co/api/v2/pokemon/1/ -> 1
 */
function extractIdFromUrl(url: string): number {
  const parts = url.trim().split('/');
  const idPart = parts[parts.length - 2]; // 뒤에서 두 번째 부분이 ID
  return parseInt(idPart, 10);
}

/**
 * PokeApiListItem을 PokemonListItem으로 변환하는 함수
 */
function mapToPokemonListItem(item: { name: string; url: string }): PokemonListItem {
  return {
    id: extractIdFromUrl(item.url),
    name: item.name,
    url: item.url,
  };
}

/**
 * PokeAPI에서 포켓몬 리스트를 가져오는 함수
 * 
 * @param offset 가져올 데이터의 시작 위치 (기본값: 0)
 * @param limit 가져올 데이터의 개수 (기본값: 20)
 * @returns 변환된 PokemonListItem 배열
 * @throws 네트워크 오류 또는 데이터 파싱 오류 발생 시 에러를 던짐
 */
export async function fetchPokemonList(
  offset: number = 0,
  limit: number = DEFAULT_FETCH_LIMIT
): Promise<PokemonListItem[]> {
  const queryParams = new URLSearchParams({
    limit: limit.toString(),
    offset: offset.toString(),
  });

  const url = `${POKEAPI_BASE_URL}/pokemon?${queryParams.toString()}`;

  try {
    const response = await fetch(url, {
      // Next.js fetch 옵션: 캐싱 전략 설정
      // 'force-cache'는 데이터 변경이 잦지 않은 포켓몬 도감 데이터에 적합
      next: { revalidate: 60 * 60 * 24 }, // 24시간마다 재검증 (ISR)
    });

    if (!response.ok) {
      throw new Error(`API 요청 실패: ${response.status} ${response.statusText}`);
    }

    const rawData: unknown = await response.json();

    // 런타임 데이터 무결성 검증
    if (!validatePokemonList(rawData)) {
      throw new Error('API 응답 데이터가 예상된 스키마와 일치하지 않습니다.');
    }

    const validatedData: PokeApiListResponse = rawData;

    // 애플리케이션 표준 타입으로 변환
    return validatedData.results.map(mapToPokemonListItem);
  } catch (error) {
    // 에러 로깅 또는 재처리 로직이 필요할 경우 여기에 추가
    console.error('fetchPokemonList 호출 중 에러 발생:', error);
    throw error;
  }
}
```
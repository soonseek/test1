```markdown
## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getPokemonList } from '@/lib/api/pokemon';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // 쿼리 파라미터 파싱 및 기본값 설정
    const offset = parseInt(searchParams.get('offset') || '0', 10);
    const limit = parseInt(searchParams.get('limit') || '20', 10);

    // 데이터 획득
    const data = await getPokemonList(offset, limit);

    // 성공 응답 반환
    return NextResponse.json(data, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        // 필요한 경우 CORS 헤더 추가 가능
        // 'Access-Control-Allow-Origin': '*', 
      },
    });
  } catch (error) {
    console.error('API Route Error:', error);
    
    // 에러 발생 시 500 반환
    return NextResponse.json(
      { error: 'Internal Server Error', message: 'Failed to fetch pokemon data' },
      { status: 500 }
    );
  }
}
```

## 파일: src/lib/api/pokemon.ts

```typescript
import { prisma } from '@/lib/db/prisma';
import { PokemonListResponse, PokemonListItem } from '@/types/pokemon';

const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2/pokemon';
// 캐시 유효기간 (예: 24시간)
const CACHE_TTL_MS = 24 * 60 * 60 * 1000; 

/**
 * 포켓몬 목록을 가져옵니다. 
 * Cache-Aside 패턴을 사용하여 DB를 확인하고, 없으면 PokeAPI를 호출합니다.
 */
export async function getPokemonList(offset: number, limit: number): Promise<PokemonListResponse> {
  const now = new Date();

  // 1. DB 캐시 조회 시도 (ID 범위 기반 조회)
  // PokeAPI는 ID가 1부터 순차적으로 증가하므로, offset/limit을 ID 범위으로 변환하여 조회
  const startId = offset + 1;
  const endId = offset + limit;

  const cachedItems = await prisma.pokemonCache.findMany({
    where: {
      id: {
        gte: startId,
        lte: endId,
      },
    },
    orderBy: {
      id: 'asc',
    },
  });

  // 2. 캐시 유효성 검증 (데이터 개수 확인 및 TTL 확인)
  // 요청한 개수만큼 캐시가 있고, 가장 오래된 데이터가 TTL 내에 있는지 확인
  const isCacheValid = cachedItems.length === limit && 
                       cachedItems.every(item => {
                         const updatedTime = new Date(item.updatedAt).getTime();
                         return (now.getTime() - updatedTime) < CACHE_TTL_MS;
                       });

  if (isCacheValid) {
    // 캐시 히트: 데이터 변환 후 반환
    const results: PokemonListItem[] = cachedItems.map(mapDbToPokemonListItem);
    
    return {
      count: -1, // 캐시에서는 전체 개수를 정확히 알기 어려우므로 -1 또는 별도 로직 필요
      next: offset + limit < 10000 ? `/api/pokemon?offset=${offset + limit}&limit=${limit}` : null, // 임시 처리
      previous: offset > 0 ? `/api/pokemon?offset=${Math.max(0, offset - limit)}&limit=${limit}` : null,
      results,
    };
  }

  // 3. 캐시 미스: PokeAPI 호출
  const response = await fetch(`${POKEAPI_BASE_URL}?offset=${offset}&limit=${limit}`, {
    next: { revalidate: 3600 }, // Next.js Fetch Cache (1시간)
  });

  if (!response.ok) {
    throw new Error(`PokeAPI fetch failed: ${response.statusText}`);
  }

  const apiData: any = await response.json();

  // 4. DB 저장 (Upsert) - 비동기로 처리하여 응답 속도 저하 방지 (또는 await으로 보장)
  // 여기서는 데이터 일관성을 위해 await 후 반환하도록 구현
  const savePromises = apiData.results.map(async (item: any) => {
    const detailRes = await fetch(item.url);
    const detailData = await detailRes.json();

    return prisma.pokemonCache.upsert({
      where: { id: detailData.id },
      update: {
        name: detailData.name,
        types: JSON.stringify(detailData.types.map((t: any) => t.type.name)),
        imageUrl: detailData.sprites.front_default,
        data: detailData,
      },
      create: {
        id: detailData.id,
        name: detailData.name,
        types: JSON.stringify(detailData.types.map((t: any) => t.type.name)),
        imageUrl: detailData.sprites.front_default,
        data: detailData,
      },
    });
  });

  await Promise.all(savePromises);

  // 5. API 데이터 변환 후 반환
  const results: PokemonListItem[] = apiData.results.map((item: any) => ({
    id: parseInt(item.url.split('/').filter(Boolean).pop() || '0', 10),
    name: item.name,
    // 상세 데이터가 필요하면 여기서 추가 매핑 필요 (위 루프에서 detailData를 활용하면 좋음)
    // 간단한 구현을 위해 ID와 Name만 반환하거나, 위에서 저장한 데이터를 재조회해서 반환할 수 있음
    // 여기서는 PokeAPI 리스트 응답 구조를 따름
    url: item.url, 
  }));

  return {
    count: apiData.count,
    next: apiData.next,
    previous: apiData.previous,
    results,
  };
}

// DB 스키마 -> 애플리케이션 타입 변환 헬퍼
function mapDbToPokemonListItem(dbItem: any): PokemonListItem {
  return {
    id: dbItem.id,
    name: dbItem.name,
    types: JSON.parse(dbItem.types || '[]'),
    imageUrl: dbItem.imageUrl,
  };
}
```

## 파일: src/lib/db/prisma.ts

```typescript
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

## 파일: prisma/schema.prisma

```prisma
// Prisma Schema 파일
// 데이터베이스 공급자 설정 (PostgreSQL 예정)
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// 포켓몬 캐시 테이블 정의
model PokemonCache {
  id        Int      @id // PokeAPI의 포켓몬 ID
  name      String
  types     String   // JSON 형태로 저장 (예: "fire,flying" 또는 JSON 배열 문자열)
  imageUrl  String?
  data      Json     // 전체 원본 데이터 저장
  updatedAt DateTime @updatedAt

  @@map("pokemon_cache")
}
```

## 파일: src/types/pokemon.ts

```typescript
// 포켓몬 리스트 아이템 인터페이스
export interface PokemonListItem {
  id: number;
  name: string;
  types?: string[]; // DB 캐시에서 반환될 때 포함
  imageUrl?: string; // DB 캐시에서 반환될 때 포함
  url?: string; // PokeAPI 원본 응답에서 반환될 때 포함
}

// 포켓몬 리스트 응답 인터페이스
export interface PokemonListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokemonListItem[];
}
```
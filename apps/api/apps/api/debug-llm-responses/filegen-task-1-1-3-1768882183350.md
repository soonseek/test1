```markdown
## 파일: src/types/pokemon.ts

```typescript
/**
 * PokeAPI 리스트 응답 타입
 * GET /pokemon?limit=... 의 results 항목
 */
export interface PokeApiListItem {
  name: string;
  url: string;
}

/**
 * PokeAPI 상세 응답 타입
 * GET /pokemon/{id} 의 전체 응답
 */
export interface PokeApiDetail {
  id: number;
  name: string;
  height: number; // decimetres
  weight: number; // hectograms
  sprites: {
    front_default: string | null;
    other: {
      'official-artwork': {
        front_default: string | null;
      };
    };
  };
  types: {
    slot: number;
    type: {
      name: string;
      url: string;
    };
  }[];
  stats: {
    base_stat: number;
    effort: number;
    stat: {
      name: string;
      url: string;
    };
  }[];
  species: {
    name: string;
    url: string;
  };
}

/**
 * 클라이언트 목록 페이지용 DTO
 */
export interface PokemonListItem {
  id: number;
  name: string;
  imageUrl: string;
  types: string[];
}

/**
 * 클라이언트 상세 페이지용 DTO
 */
export interface PokemonDetailItem {
  id: number;
  name: string;
  imageUrl: string;
  types: string[];
  height: number; // meters
  weight: number; // kg
  stats: {
    name: string;
    value: number;
  }[];
}
```

## 파일: src/lib/mappers/pokemon.mapper.ts

```typescript
import { PokeApiDetail, PokemonListItem, PokemonDetailItem } from '@/types/pokemon';

const PLACEHOLDER_IMAGE = 'https://via.placeholder.com/96?text=No+Img';

/**
 * PokeAPI 상세 데이터를 클라이언트 목록용 DTO로 변환합니다.
 */
export function toPokemonListItem(apiData: PokeApiDetail): PokemonListItem {
  // 공식 아트워크 우선, 없으면 기본 이미지, 없으면 플레이스홀더
  const imageUrl =
    apiData.sprites.other?.['official-artwork']?.front_default ||
    apiData.sprites.front_default ||
    PLACEHOLDER_IMAGE;

  return {
    id: apiData.id,
    name: apiData.name,
    imageUrl,
    types: apiData.types.map((t) => t.type.name),
  };
}

/**
 * PokeAPI 상세 데이터를 클라이언트 상세용 DTO로 변환합니다.
 */
export function toPokemonDetailItem(apiData: PokeApiDetail): PokemonDetailItem {
  const imageUrl =
    apiData.sprites.other?.['official-artwork']?.front_default ||
    apiData.sprites.front_default ||
    PLACEHOLDER_IMAGE;

  return {
    id: apiData.id,
    name: apiData.name,
    imageUrl,
    types: apiData.types.map((t) => t.type.name),
    // 단위 변환: decimetres -> meters, hectograms -> kg
    height: apiData.height / 10,
    weight: apiData.weight / 10,
    stats: apiData.stats.map((s) => ({
      name: s.stat.name,
      value: s.base_stat,
    })),
  };
}
```

## 파일: src/lib/utils/pokeapi.ts

```typescript
/**
 * PokeAPI 원본 호출을 담당하는 저수준 유틸리티 모듈
 */

const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2';

export interface PokeApiListResponse<T> {
  count: number;
  next: string | null;
  previous: string | null;
  results: T[];
}

/**
 * PokeAPI 호출을 위한 공통 Fetch 래퍼 함수
 * Next.js 캐싱 전략(next.revalidate)을 적용합니다.
 */
export async function fetchPokeApi<T>(
  endpoint: string,
  options?: RequestInit
): Promise<T> {
  const url = `${POKEAPI_BASE_URL}${endpoint}`;

  const res = await fetch(url, {
    ...options,
    // 60초 동안 데이터 캐싱 (ISR)
    next: { revalidate: 60 },
  });

  if (!res.ok) {
    throw new Error(`PokeAPI request failed: ${res.status} ${res.statusText}`);
  }

  return res.json() as Promise<T>;
}
```

## 파일: src/lib/api/pokemon.api.ts

```typescript
import { fetchPokeApi, PokeApiListResponse } from '@/lib/utils/pokeapi';
import { PokeApiListItem, PokeApiDetail, PokemonListItem, PokemonDetailItem } from '@/types/pokemon';
import { toPokemonListItem, toPokemonDetailItem } from '@/lib/mappers/pokemon.mapper';

/**
 * 포켓몬 목록을 가져와서 변환합니다.
 * @param offset 건너뛸 개수
 * @param limit 가져올 개수
 */
export async function fetchPokemonList(offset = 0, limit = 20): Promise<PokemonListItem[]> {
  // 1. 목록 메타데이터 가져오기
  const listData = await fetchPokeApi<PokeApiListResponse<PokeApiListItem>>(
    `/pokemon?offset=${offset}&limit=${limit}`
  );

  // 2. 각 포켓몬의 상세 정보를 병렬로 가져오기
  // 목록 API는 이미지 URL을 포함하고 있지 않으므로 상세 API 호출이 필요함
  const detailPromises = listData.results.map((item) => {
    // URL에서 ID 추출 (예: https://pokeapi.co/api/v2/pokemon/1/)
    const id = item.url.split('/').filter(Boolean).pop();
    return fetchPokeApi<PokeApiDetail>(`/pokemon/${id}`);
  });

  const details = await Promise.all(detailPromises);

  // 3. DTO로 변환하여 반환
  return details.map(toPokemonListItem);
}

/**
 * 특정 ID의 포켓몬 상세 정보를 가져와서 변환합니다.
 */
export async function fetchPokemonDetail(id: number): Promise<PokemonDetailItem> {
  const detail = await fetchPokeApi<PokeApiDetail>(`/pokemon/${id}`);
  return toPokemonDetailItem(detail);
}
```

## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { fetchPokemonList } from '@/lib/api/pokemon.api';

/**
 * 포켓몬 목록 API Route Handler
 * GET /api/pokemon?page=1&limit=20
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // 쿼리 파라미터 파싱 및 검증
    const pageParam = searchParams.get('page');
    const limitParam = searchParams.get('limit');

    const page = parseInt(pageParam || '1', 10);
    const limit = parseInt(limitParam || '20', 10);

    if (isNaN(page) || page < 1) {
      return NextResponse.json(
        { error: 'Invalid page parameter' },
        { status: 400 }
      );
    }

    if (isNaN(limit) || limit < 1 || limit > 100) {
      return NextResponse.json(
        { error: 'Invalid limit parameter (max 100)' },
        { status: 400 }
      );
    }

    // offset 계산
    const offset = (page - 1) * limit;

    // 데이터 페칭 및 변환
    const data = await fetchPokemonList(offset, limit);

    // 성공 응답
    return NextResponse.json({
      data,
      pagination: {
        page,
        limit,
        count: data.length,
      },
    });
  } catch (error) {
    console.error('Error in /api/pokemon:', error);
    
    // 에러 응답
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    );
  }
}
```
```markdown
## 파일: src/types/pokemon.ts

```typescript
/**
 * PokeAPI v2 pokemon 리스트 엔드포인트의 원본 응답 구조
 */
export interface PokeAPIListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: {
    name: string;
    url: string;
  }[];
}

/**
 * 클라이언트로 반환할 간소화된 포켓몬 아이템 구조
 */
export interface PokemonListItem {
  id: number;
  name: string;
  url: string;
}

/**
 * 에러 응답을 위한 공통 구조
 */
export interface APIError {
  success: false;
  message: string;
}
```

## 파일: src/lib/utils/pokemon.ts

```typescript
import { PokeAPIListResponse, PokemonListItem } from '@/types/pokemon';

/**
 * URL 문자열(예: https://pokeapi.co/api/v2/pokemon/1/)에서 숫자 ID를 추출하는 헬퍼 함수
 */
export function extractIdFromUrl(url: string): number {
  const urlParts = url.split('/');
  // URL 구조: .../pokemon/{id}/
  const idPart = urlParts[urlParts.length - 2]; 
  return parseInt(idPart, 10);
}

/**
 * PokeAPI 리스트 응답을 받아 results 배열을 순회하며 
 * URL에서 ID를 추출하고, 필요한 필드만 매핑하여 반환하는 함수
 */
export function formatPokemonList(apiResponse: PokeAPIListResponse): PokemonListItem[] {
  return apiResponse.results.map((item) => {
    const id = extractIdFromUrl(item.url);
    return {
      id,
      name: item.name,
      url: item.url,
    };
  });
}
```

## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { PokeAPIListResponse, PokemonListItem, APIError } from '@/types/pokemon';
import { formatPokemonList } from '@/lib/utils/pokemon';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const limit = searchParams.get('limit');
    const offset = searchParams.get('offset');

    // 쿼리 파라미터 유효성 검사 (숫자만 허용)
    const limitNum = limit ? parseInt(limit, 10) : 20;
    const offsetNum = offset ? parseInt(offset, 10) : 0;

    if (
      (limit && isNaN(limitNum)) ||
      (offset && isNaN(offsetNum)) ||
      limitNum < 0 ||
      offsetNum < 0
    ) {
      const errorResponse: APIError = {
        success: false,
        message: 'Invalid query parameters. limit and offset must be positive numbers.',
      };
      return NextResponse.json(errorResponse, { status: 400 });
    }

    // PokeAPI 호출
    const apiUrl = new URL('https://pokeapi.co/api/v2/pokemon');
    if (limit) apiUrl.searchParams.set('limit', limitNum.toString());
    if (offset) apiUrl.searchParams.set('offset', offsetNum.toString());

    const response = await fetch(apiUrl.toString());

    if (!response.ok) {
      throw new Error(`PokeAPI fetch failed: ${response.statusText}`);
    }

    const data: PokeAPIListResponse = await response.json();
    const formattedData: PokemonListItem[] = formatPokemonList(data);

    // 성공 응답 (200 OK)
    return NextResponse.json(
      { data: formattedData },
      {
        status: 200,
        headers: {
          'Cache-Control': 'public, max-age=60', // 60초 캐싱
        },
      }
    );
  } catch (error) {
    console.error('Error in /api/pokemon:', error);
    
    const errorResponse: APIError = {
      success: false,
      message: 'Internal Server Error: Failed to fetch pokemon data.',
    };

    // 실패 응답 (500 Internal Server Error)
    return NextResponse.json(errorResponse, { status: 500 });
  }
}
```
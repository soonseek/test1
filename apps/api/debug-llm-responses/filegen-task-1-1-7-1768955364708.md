```markdown
## 파일: src/types/error.ts

```typescript
/**
 * API 에러 처리를 위한 커스텀 에러 클래스
 */
export class ApiError extends Error {
  public statusCode: number;
  public code: string;

  constructor(message: string, statusCode: number = 500, code: string = 'INTERNAL_ERROR') {
    super(message);
    this.name = 'ApiError';
    this.statusCode = statusCode;
    this.code = code;

    // 프로토타입 체인 유지 (V8 엔진 최적화)
    Object.setPrototypeOf(this, ApiError.prototype);
  }
}

/**
 * PokeAPI 관련 특화 에러
 */
export class PokeApiError extends ApiError {
  constructor(message: string, statusCode: number = 502) {
    super(message, statusCode, 'POKEAPI_ERROR');
    this.name = 'PokeApiError';
  }
}

/**
 * 데이터 무결성 검증 실패 에러
 */
export class ValidationError extends ApiError {
  constructor(message: string) {
    super(message, 500, 'VALIDATION_ERROR');
    this.name = 'ValidationError';
  }
}
```

## 파일: src/lib/api/pokemon.ts

```typescript
import { PokeApiError, ValidationError } from '@/types/error';

// PokeAPI 응답 타입 정의 (간소화됨)
interface PokeApiListItem {
  name: string;
  url: string;
}

interface PokeApiResponse {
  results: PokeApiListItem[];
}

export interface PokemonListItem {
  id: string;
  name: string;
}

/**
 * PokeAPI에서 포켓몬 목록을 가져오는 함수
 * 네트워크 에러 및 데이터 무결성 검증을 수행합니다.
 */
export async function fetchPokemonList(): Promise<PokemonListItem[]> {
  try {
    const response = await fetch('https://pokeapi.co/api/v2/pokemon?limit=151');

    if (!response.ok) {
      // PokeAPI 서버가 응답하지만 에러 상태를 반환한 경우
      throw new PokeApiError(
        `PokeAPI request failed with status ${response.status}`,
        response.status === 404 ? 404 : 502
      );
    }

    const data: unknown = await response.json();

    // 데이터 무결성 검증 (Data Validation)
    if (!isPokeApiResponse(data)) {
      throw new ValidationError('Invalid response structure from PokeAPI');
    }

    // 데이터 가공
    return data.results.map((item) => {
      // URL에서 ID 추출 (예: https://pokeapi.co/api/v2/pokemon/1/ -> 1)
      const id = item.url.split('/').filter(Boolean).pop();
      return {
        id: id || 'unknown',
        name: item.name,
      };
    });
  } catch (error) {
    // 네트워크 연결 자체가 실패한 경우 (fetch 자체가 실패)
    if (error instanceof TypeError && error.message.includes('fetch')) {
      throw new PokeApiError('Failed to connect to PokeAPI. Network error.');
    }

    // 이미 정의된 에러(Class)인 경우 그대로 전파
    if (error instanceof Error) {
      throw error;
    }

    // 그 외 알 수 없는 에러
    throw new Error('An unexpected error occurred while fetching Pokemon list');
  }
}

/**
 * PokeAPI 응답 구조 검증을 위한 타입 가드
 */
function isPokeApiResponse(data: unknown): data is PokeApiResponse {
  return (
    typeof data === 'object' &&
    data !== null &&
    'results' in data &&
    Array.isArray((data as PokeApiResponse).results)
  );
}
```

## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextResponse } from 'next/server';
import { fetchPokemonList } from '@/lib/api/pokemon';
import { ApiError } from '@/types/error';

export async function GET() {
  try {
    // 라이브러리 호출
    const data = await fetchPokemonList();

    // 정상 응답 반환
    return NextResponse.json(data, { status: 200 });
  } catch (error) {
    console.error('[API Route] Error fetching pokemon:', error);

    // 커스텀 ApiError 처리
    if (error instanceof ApiError) {
      return NextResponse.json(
        {
          error: error.message,
          code: error.code,
        },
        { status: error.statusCode }
      );
    }

    // 그 외 일반 에러 처리 (안전장치)
    return NextResponse.json(
      {
        error: 'Internal Server Error',
        message: 'Failed to fetch data due to an unexpected error.',
      },
      { status: 500 }
    );
  }
}
```
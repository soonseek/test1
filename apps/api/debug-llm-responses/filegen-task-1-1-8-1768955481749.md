```markdown
## 파일: src/types/pokemon.ts

```typescript
/**
 * PokeAPI v2 pokemon 리스트 엔드포인트의 원본 응답 형태
 */
export interface PokeAPIListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokeAPIResult[];
}

/**
 * PokeAPI results 배열 내부의 객체 형태
 */
export interface PokeAPIResult {
  name: string;
  url: string;
}

/**
 * 클라이언트로 반환할 최종 데이터 형태
 * URL에서 ID를 추출하여 포함
 */
export interface PokemonListItem {
  id: number;
  name: string;
}
```

## 파일: src/lib/api/pokeapi.ts

```typescript
import { PokeAPIListResponse, PokemonListItem } from '@/types/pokemon';

/**
 * PokeAPI에서 포켓몬 리스트를 가져오는 함수
 * @param offset 건너뛸 데이터 수
 * @param limit 가져올 데이터 수
 * @returns 가공된 포켓몬 리스트
 */
export async function fetchPokemonList(
  offset: number = 0,
  limit: number = 20
): Promise<PokemonListItem[]> {
  const url = `https://pokeapi.co/api/v2/pokemon?offset=${offset}&limit=${limit}`;

  try {
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`PokeAPI fetch failed: ${response.statusText}`);
    }

    const data: PokeAPIListResponse = await response.json();

    // URL에서 ID 추출 및 데이터 매핑
    // URL 예시: https://pokeapi.co/api/v2/pokemon/1/
    const mappedData: PokemonListItem[] = data.results.map((item) => {
      const urlSegments = item.url.split('/');
      const id = Number(urlSegments[urlSegments.length - 2]);
      
      return {
        id,
        name: item.name,
      };
    });

    return mappedData;
  } catch (error) {
    // 네트워크 오류 발생 시 Error 객체 throw
    if (error instanceof Error) {
      throw error;
    }
    throw new Error('Unknown error occurred while fetching Pokemon data');
  }
}
```

## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { fetchPokemonList } from '@/lib/api/pokeapi';

/**
 * GET /api/pokemon
 * 포켓몬 리스트를 반환하는 API 핸들러
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // 쿼리 파라미터 파싱 및 기본값 설정
    const offset = Number(searchParams.get('offset')) || 0;
    const limit = Number(searchParams.get('limit')) || 20;

    // 데이터 페칭
    const data = await fetchPokemonList(offset, limit);

    // 성공 시 200 OK와 함께 데이터 반환
    return NextResponse.json(data, { status: 200 });
  } catch (error) {
    console.error('API Route Error:', error);
    
    // 실패 시 500 Internal Server Error 반환
    const errorMessage = error instanceof Error ? error.message : 'Internal Server Error';
    return NextResponse.json(
      { error: errorMessage },
      { status: 500 }
    );
  }
}
```

## 파일: src/app/api/pokemon/route.test.ts

```typescript
import { GET } from './route';
import { fetchPokemonList } from '@/lib/api/pokeapi';
import { NextRequest } from 'next/server';

// 모듈 모킹
jest.mock('@/lib/api/pokeapi');

describe('Pokemon API Route', () => {
  it('should return a list of pokemon with status 200', async () => {
    // 모킹 데이터 설정
    const mockData = [
      { id: 1, name: 'bulbasaur' },
      { id: 2, name: 'ivysaur' },
    ];
    (fetchPokemonList as jest.Mock).mockResolvedValue(mockData);

    // 가상의 Request 객체 생성
    const request = new NextRequest('http://localhost:3000/api/pokemon?offset=0&limit=2');

    // 핸들러 실행
    const response = await GET(request);
    const json = await response.json();

    // 검증
    expect(response.status).toBe(200);
    expect(json).toEqual(mockData);
    expect(fetchPokemonList).toHaveBeenCalledWith(0, 2);
  });

  it('should use default offset and limit if not provided', async () => {
    const mockData = [];
    (fetchPokemonList as jest.Mock).mockResolvedValue(mockData);

    const request = new NextRequest('http://localhost:3000/api/pokemon');
    
    await GET(request);

    expect(fetchPokemonList).toHaveBeenCalledWith(0, 20);
  });

  it('should return 500 error if fetching fails', async () => {
    const errorMessage = 'Network Error';
    (fetchPokemonList as jest.Mock).mockRejectedValue(new Error(errorMessage));

    const request = new NextRequest('http://localhost:3000/api/pokemon');
    
    const response = await GET(request);
    const json = await response.json();

    expect(response.status).toBe(500);
    expect(json.error).toBe(errorMessage);
  });
});
```
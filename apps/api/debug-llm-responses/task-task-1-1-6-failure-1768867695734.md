작업을 시작하겠습니다.

이 Task는 `getPokemonList` 함수에 **DB 캐싱 로직(Cache-Aside Pattern)**을 통합하는 작업입니다. 요청하신 대로 **단일 Next.js 앱** 구조(`src/` 루트)를 준수하여 코드를 작성합니다.

### 구현 전략
1.  **Prisma Client 로직**: `PokemonCache` 테이블을 먼저 조회합니다.
2.  **캐시 히트 (Cache Hit)**: 데이터가 있고, 유효 기간(예: 1시간) 내라면 DB 데이터를 반환합니다.
3.  **캐시 미스 (Cache Miss)**: 데이터가 없거나 만료되었다면, PokeAPI를 호출합니다.
4.  **역정규화 (Denormalization)**: 가져온 데이터를 즉시 DB `PokemonCache` 테이블에 `upsert`하여 다음 요청 시 빠르게 접근할 수 있게 합니다.

---

## 파일: src/lib/api/pokemon.ts

이 파일은 포켓몬 데이터를 가져오는 핵심 로직을 담당합니다. DB 캐싱 로직이 포함된 `getPokemonList` 함수를 구현합니다.

```typescript
import { PrismaClient } from '@prisma/client';

// PrismaClient 인스턴스는 개발 환경에서 핫 리로딩 시 연결이 중복되지 않도록 처리
const globalForPrisma = global as unknown as { prisma: PrismaClient };
const prisma = globalForPrisma.prisma || new PrismaClient();
if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

// PokeAPI 응답 타입 정의
export interface PokemonListItem {
  name: string;
  url: string;
}

export interface PokemonListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokemonListItem[];
}

// 캐시 유효 기간 (밀리초 단위) - 예: 1시간
const CACHE_TTL_MS = 60 * 60 * 1000; 

/**
 * 포켓몬 목록을 가져오는 함수입니다.
 * 1. DB(PokemonCache)를 먼저 조회합니다.
 * 2. 데이터가 있고 유효하다면 반환합니다.
 * 3. 없거나 만료되었다면 PokeAPI를 호출하고 DB에 저장(Caching)한 뒤 반환합니다.
 */
export async function getPokemonList(offset = 0, limit = 20): Promise<PokemonListResponse> {
  const cacheKey = `pokemon-list-${offset}-${limit}`;
  const now = new Date();

  try {
    // 1. DB 캐시 조회 시도
    const cachedData = await prisma.pokemonCache.findUnique({
      where: { id: cacheKey },
    });

    // 2. 캐시 유효성 검사 (데이터가 있고, TTL 내인지 확인)
    if (cachedData) {
      const updatedAt = new Date(cachedData.updatedAt);
      const isExpired = now.getTime() - updatedAt.getTime() > CACHE_TTL_MS;

      if (!isExpired) {
        console.log(`[Cache Hit] ${cacheKey}`);
        // JSON 데이터를 파싱하여 반환
        return cachedData.data as PokemonListResponse;
      } else {
        console.log(`[Cache Expired] ${cacheKey}`);
      }
    } else {
      console.log(`[Cache Miss] ${cacheKey}`);
    }

    // 3. 캐시 미스 또는 만료 시 PokeAPI 호출
    console.log(`[Fetching API] PokeAPI 호출 중...`);
    const response = await fetch(`https://pokeapi.co/api/v2/pokemon?offset=${offset}&limit=${limit}`, {
      // Next.js의 기본 캐싱보다 DB 캐싱이 우선되도록 설정하거나, 
      // 네트워크 요청 자체도 최적화하기 위해 next.revalidate 사용 가능
      next: { revalidate: 3600 } 
    });

    if (!response.ok) {
      throw new Error('PokeAPI 네트워크 응답에 실패했습니다.');
    }

    const data: PokemonListResponse = await response.json();

    // 4. DB에 캐시 저장 (Upsert)
    // Prisma의 upsert를 사용하여 ID가 있으면 업데이트(시간 갱신), 없으면 생성
    await prisma.pokemonCache.upsert({
      where: { id: cacheKey },
      update: {
        data: data,
        updatedAt: now, // 명시적으로 시간 갱신
      },
      create: {
        id: cacheKey,
        data: data,
      },
    });

    console.log(`[Cache Saved] ${cacheKey} 저장 완료`);
    return data;

  } catch (error) {
    console.error('[getPokemonList Error]', error);
    // API 호출 실패 시, 만료된 캐시라도 보여줄지 여부는 정책에 따라 다름
    // 여기서는 에러를 던지도록 함
    throw new Error('포켓몬 목록을 불러오는데 실패했습니다.');
  }
}

/**
 * (선택 사항) 특정 ID의 포켓몬 상세 정보를 가져오는 함수
 * 향후 Story에서 구현될 수 있으나 구조를 위해 기본 형태만 남김
 */
export async function getPokemonDetail(id: string) {
  // TODO: 상세 정보도 동일한 캐싱 로직 적용 가능
  return null;
}
```

---

## 파일: src/app/page.tsx

메인 페이지에서 위에서 작성한 `getPokemonList` 함수를 사용하여 데이터를 렌더링합니다. Server Component 특성을 활용하여 서버 사이드에서 데이터를 가져옵니다.

```typescript
import { getPokemonList } '@/lib/api/pokemon';
import Link from 'next/link';

// 메인 페이지 컴포넌트 (Server Component)
export default async function Home() {
  // 초기 데이터 로드 (offset 0, limit 20)
  // DB 캐싱 로직이 적용되어 있어, 첫 로딩 이후부터는 DB에서 빠르게 조회됨
  const pokemonData = await getPokemonList(0, 20);

  return (
    <main className="min-h-screen bg-gray-50 dark:bg-gray-900 p-8">
      <div className="max-w-4xl mx-auto">
        <header className="mb-8 flex justify-between items-center">
          <h1 className="text-3xl font-bold text-yellow-500">Pokedex</h1>
          <span className="text-sm text-gray-500">Powered by PokeAPI + Prisma Cache</span>
        </header>

        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          {pokemonData.results.map((pokemon) => {
            // URL에서 ID 추출 (예: https://pokeapi.co/api/v2/pokemon/1/)
            const id = pokemon.url.split('/').filter(Boolean).pop();
            
            return (
              <Link 
                key={pokemon.name} 
                href={`/pokemon/${id}`}
                className="block p-4 bg-white dark:bg-gray-800 rounded-lg shadow hover:shadow-lg transition-shadow border border-gray-200 dark:border-gray-700"
              >
                <div className="aspect-square bg-gray-100 dark:bg-gray-700 rounded mb-3 flex items-center justify-center text-gray-400">
                  {/* 이미지 로딩 로직은 추후 구현, 여기서는 플레이스홀더 */}
                  <span className="text-xs">No Image</span>
                </div>
                <div className="text-center">
                  <p className="font-semibold capitalize text-gray-800 dark:text-gray-100">
                    {pokemon.name}
                  </p>
                  <p className="text-xs text-gray-500">#{id}</p>
                </div>
              </Link>
            );
          })}
        </div>

        <div className="mt-8 text-center">
          <button className="px-6 py-2 bg-blue-600 text-white rounded-full hover:bg-blue-700 transition-colors">
            Load More
          </button>
        </div>
      </div>
    </main>
  );
}
```

---

## 파일: prisma/schema.prisma

캐싱 로직이 정상 작동하려면 데이터베이스 스키마가 정의되어 있어야 합니다. `PokemonCache` 모델이 포함된 스키마 파일입니다. (이미 존재한다면 내용을 확인해주세요.)

```prisma
// Prisma Schema 파일
// 데이터베이스 모델 정의

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // 또는 사용하는 DB (mysql, sqlite 등)
  url      = env("DATABASE_URL")
}

// 포켓몬 캐시 테이블
// PokeAPI의 응답을 JSON 형태로 저장하여 캐싱합니다.
model PokemonCache {
  id        String   @id // 캐시 키 (예: pokemon-list-0-20)
  data      Json     // API 응답 전체 데이터 (JSON 형태)
  updatedAt DateTime @updatedAt // 자동 업데이트 시간
}

// 추후 사용자 기능 구현 시 사용할 모델 (PRD 참조)
model User {
  id        String   @id @default(uuid())
  deviceId  String   @unique
  createdAt DateTime @default(now())
}

model FavoritePokemon {
  id           String   @id @default(uuid())
  userId       String
  pokemonId    Int
  pokemonName  String
  createdAt    DateTime @default(now())
  
  // 관계 설정 (선택 사항)
  // user         User     @relation(fields: [userId], references: [id])
}
```
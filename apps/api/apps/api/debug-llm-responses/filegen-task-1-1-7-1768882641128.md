```markdown
## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getPokemonList } from '@/lib/api/pokemon';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // 쿼리 파라미터 파싱 및 기본값 설정
    const offset = parseInt(searchParams.get('offset') || '0', 10);
    const limit = parseInt(searchParams.get('limit') || '20', 10);

    // 데이터 가져오기
    const data = await getPokemonList(offset, limit);

    // JSON 형식으로 반환
    return NextResponse.json(data);
  } catch (error) {
    console.error('API Route Error:', error);
    return NextResponse.json(
      { error: 'Internal Server Error', message: '포켓몬 데이터를 가져오는 데 실패했습니다.' },
      { status: 500 }
    );
  }
}
```

## 파일: src/lib/api/pokemon.ts

```typescript
import { PrismaClient } from '@prisma/client';
import prisma from './prisma';

// PokeAPI 응답 타입 정의
type PokeAPIResult = {
  name: string;
  url: string;
};

type PokeAPIResponse = {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokeAPIResult[];
};

type PokeAPISprites = {
  other: {
    'official-artwork': {
      front_default: string | null;
    };
  };
};

type PokeAPIPokemonDetail = {
  id: number;
  name: string;
  sprites: PokeAPISprites;
};

// 반환할 포켓몬 데이터 타입
export type PokemonListItem = {
  id: number;
  name: string;
  imageUrl: string;
};

/**
 * PokeAPI에서 데이터를 가져와 가공하는 함수
 */
async function fetchPokemonListFromAPI(offset: number, limit: number): Promise<PokemonListItem[]> {
  const response = await fetch(`https://pokeapi.co/api/v2/pokemon?offset=${offset}&limit=${limit}`);
  
  if (!response.ok) {
    throw new Error('Failed to fetch data from PokeAPI');
  }

  const data: PokeAPIResponse = await response.json();

  // 상세 정보(이미지 URL 등)를 가져오기 위해 각 포켓몬별로 추가 요청
  // 병렬 처리를 위해 Promise.all 사용
  const detailedPokemonPromises = data.results.map(async (pokemon) => {
    const id = pokemon.url.split('/').filter(Boolean).pop(); // URL에서 ID 추출
    const detailRes = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
    const detailData: PokeAPIPokemonDetail = await detailRes.json();

    return {
      id: detailData.id,
      name: detailData.name,
      // 공식 artwork 이미지 URL 사용
      imageUrl: detailData.sprites.other['official-artwork'].front_default || '/placeholder.png',
    };
  });

  return Promise.all(detailedPokemonPromises);
}

/**
 * 캐싱 로직을 포함한 포켓몬 목록 조회 함수
 */
export async function getPokemonList(offset: number, limit: number): Promise<PokemonListItem[]> {
  // 1. DB 캐시 확인 (간단한 구현을 위해 전체 목록 캐싱 가정)
  // 실제 프로덕션에서는 offset/limit 범위에 맞는 캐시 키 전략이 필요할 수 있음
  // 여기서는 편의상 offset 0일 때만 캐싱 로직을 강하게 적용하거나,
  // 개별 ID 기반 캐싱을 수행하거나, 전체 리스트를 캐싱하고 메모리에서 자르는 방식 등이 있음.
  // 요구사항에 따라 "캐시가 없거나 만료된 경우" 로직을 수행합니다.
  
  // 예시: offset 0 요청 시 전체 캐시 확인 (데모 목적)
  const cacheKey = `pokemon_list_${offset}_${limit}`;
  
  // 캐시된 데이터 조회 로직 (Prisma 사용)
  // 실제로는 offset/limit에 맞는 레코드를 찾는 것이 복잡할 수 있으므로,
  // 여기서는 편의상 "가장 최근에 업데이트된 캐시"가 있는지 확인하는 방식으로 구현합니다.
  const cachedData = await prisma.pokemonCache.findFirst({
    where: {
      id: 1, // 예시를 위해 ID 1에 전체 리스트를 캐싱한다고 가정
      // updatedAt이 특정 시간 이내인지 확인하는 로직은 애플리케이션 레벨에서 처리
    }
  });

  const now = new Date();
  const CACHE_DURATION_MS = 60 * 60 * 1000; // 1시간

  if (cachedData) {
    const lastUpdated = new Date(cachedData.updatedAt);
    const timeDiff = now.getTime() - lastUpdated.getTime();

    if (timeDiff < CACHE_DURATION_MS) {
      // 캐시 유효함
      const allPokemon = cachedData.data as unknown as PokemonListItem[];
      // 요청된 offset과 limit에 맞게 슬라이스하여 반환
      return allPokemon.slice(offset, offset + limit);
    }
  }

  // 2. 캐시가 없거나 만료된 경우 API 호출
  const freshData = await fetchPokemonListFromAPI(offset, limit);

  // 3. DB에 저장 (Cache-Aside)
  // 편의상 offset 0 요청일 때 전체 리스트를 갱신하는 로직으로 구현
  if (offset === 0) {
    await prisma.pokemonCache.upsert({
      where: { id: 1 },
      update: {
        data: freshData as any, // Prisma Json 타입에 저장
        updatedAt: now,
      },
      create: {
        id: 1,
        data: freshData as any,
        updatedAt: now,
      },
    });
  }

  return freshData;
}
```

## 파일: src/lib/prisma.ts

```typescript
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: ['query', 'error', 'warn'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

export default prisma;
```

## 파일: prisma/schema.prisma

```prisma
// 이것은 Prisma 스키마 파일입니다. 자세한 정보는 다음에서 확인하세요: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model PokemonCache {
  id        Int      @id @default(autoincrement())
  data      Json     // 포켓몬 상세 정보 데이터 (리스트 형태)
  updatedAt DateTime @updatedAt // 캐시 유효성 확인용
}
```

## 파일: .env

```env
# PostgreSQL 데이터베이스 연결 문자열
# 예: postgresql://user:password@localhost:5432/mydb?schema=public
DATABASE_URL="postgresql://user:password@localhost:5432/pokemon_db?schema=public"
```
```markdown
## 파일: src/types/pokemon.ts

```typescript
/**
 * PokeAPI v2 /pokemon 엔드포인트의 results 배열 내부 객체 형태
 */
export interface PokeAPIResult {
  name: string;
  url: string;
}

/**
 * PokeAPI v2 /pokemon 엔드포인트의 원본 응답 형태
 */
export interface PokeAPIListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokeAPIResult[];
}

/**
 * 클라이언트로 반환할 최종 데이터 형태
 */
export interface PokemonListItem {
  id: number;
  name: string;
  url: string;
}
```

## 파일: src/lib/utils/pokemon.ts

```typescript
/**
 * PokeAPI URL(예: https://pokeapi.co/api/v2/pokemon/1/)에서
 * 숫자형 ID(예: 1)를 추출하여 반환하는 유틸리티 함수입니다.
 *
 * @param url - PokeAPI 리소스 URL
 * @returns 추출된 숫자형 ID
 */
export function extractIdFromUrl(url: string): number {
  const urlParts = url.split('/');
  // URL 구조: .../pokemon/{id}/
  const idPart = urlParts[urlParts.length - 2];
  return parseInt(idPart, 10);
}
```

## 파일: src/app/api/pokemons/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { PokeAPIListResponse, PokemonListItem } from '@/types/pokemon';
import { extractIdFromUrl } from '@/lib/utils/pokemon';

const POKEAPI_BASE_URL = process.env.NEXT_PUBLIC_POKEAPI_URL || 'https://pokeapi.co/api/v2';

/**
 * PokeAPI에서 포켓몬 목록을 가져오는 내부 함수
 */
async function fetchPokemonsFromSource(limit: number = 20, offset: number = 0): Promise<PokemonListItem[]> {
  const apiUrl = new URL(`${POKEAPI_BASE_URL}/pokemon`);
  apiUrl.searchParams.append('limit', String(limit));
  apiUrl.searchParams.append('offset', String(offset));

  const response = await fetch(apiUrl.toString());

  if (!response.ok) {
    throw new Error(`PokeAPI fetch failed: ${response.status} ${response.statusText}`);
  }

  const data: PokeAPIListResponse = await response.json();

  // 데이터 변환: URL에서 ID 추출 및 형태 변경
  return data.results.map((item) => {
    const id = extractIdFromUrl(item.url);
    return {
      id,
      name: item.name,
      url: item.url,
    };
  });
}

/**
 * GET /api/pokemons
 * 포켓몬 목록을 반환하는 핸들러
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const limit = Number(searchParams.get('limit')) || 20;
    const offset = Number(searchParams.get('offset')) || 0;

    // 쿼리 파라미터 검증 (선택 사항)
    if (limit < 0 || offset < 0) {
      return NextResponse.json(
        { error: 'Invalid query parameters. Limit and offset must be non-negative.' },
        { status: 400 }
      );
    }

    // TODO: 향후 Prisma 등을 이용한 캐싱 로직이 여기에 들어갈 수 있습니다.
    // const cachedData = await prisma.pokemonCache.findMany(...);
    // if (cachedData.length > 0) return NextResponse.json(cachedData);

    const pokemons = await fetchPokemonsFromSource(limit, offset);

    return NextResponse.json(pokemons);
  } catch (error) {
    console.error('Error in /api/pokemons:', error);
    
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    
    return NextResponse.json(
      { error: 'Failed to fetch pokemons', details: errorMessage },
      { status: 500 }
    );
  }
}
```
```markdown
## 파일: src/types/pokemon.ts

```typescript
export type PokemonType = 
  | "normal" | "fire" | "water" | "electric" | "grass" | "ice"
  | "fighting" | "poison" | "ground" | "flying" | "psychic" | "bug"
  | "rock" | "ghost" | "dragon" | "dark" | "steel" | "fairy";

export interface PokemonListItem {
  name: string;
  url: string;
  id?: number; // URL에서 추출하여 사용할 수 있음
}

export interface PokemonListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokemonListItem[];
}

export interface Pokemon {
  id: number;
  name: string;
  types: {
    slot: number;
    type: {
      name: PokemonType;
      url: string;
    };
  }[];
  sprites: {
    front_default: string;
    other: {
      "official-artwork": {
        front_default: string;
      };
    };
  };
}
```

## 파일: prisma/schema.prisma

```prisma
// Prisma Schema for Pokemon App Caching & Favorites

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// API 응답 결과를 JSON 형태로 저장하기 위한 캐시 테이블
model PokemonCache {
  id        String   @id @default(cuid())
  key       String   @unique // 캐시 키 (예: "pokemon-list", "pokemon-25")
  data      Json     // API 응답 전체 데이터
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())
}

// 사용자의 좋아요 정보를 저장하기 위한 테이블
model Favorite {
  id        String   @id @default(cuid())
  userId    String
  pokemonId Int
  createdAt DateTime @default(now())

  @@unique([userId, pokemonId])
}
```

## 파일: src/lib/api/pokemon.ts

```typescript
import { PrismaClient } from '@prisma/client';
import { PokemonListResponse, Pokemon } from '@/types/pokemon';

const prisma = new PrismaClient();

const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2';

/**
 * PokeAPI 호출을 담당하는 핵심 유틸리티 모듈
 * next.revalidate 옵션을 사용하여 ISR을 구현합니다.
 * 
 * @param revalidate - 재검증 시간(초), 기본값 60초
 */
export async function getPokemonList(revalidate: number = 60): Promise<PokemonListResponse> {
  const res = await fetch(`${POKEAPI_BASE_URL}/pokemon?limit=151`, {
    next: { revalidate }, // 60초마다 백그라운드에서 데이터 재검증 (ISR)
  });

  if (!res.ok) {
    throw new Error('Failed to fetch pokemon list');
  }

  const data: PokemonListResponse = await res.json();
  
  // URL에서 ID 추출하여 편의상 추가
  data.results = data.results.map((item) => {
    const id = item.url.split('/').filter(Boolean).pop();
    return { ...item, id: Number(id) };
  });

  return data;
}

/**
 * 개별 포켓몬 상세 정보 조회
 * @param id - 포켓몬 ID
 * @param revalidate - 재검증 시간(초), 기본값 60초
 */
export async function getPokemonDetail(id: number, revalidate: number = 60): Promise<Pokemon> {
  const res = await fetch(`${POKEAPI_BASE_URL}/pokemon/${id}`, {
    next: { revalidate },
  });

  if (!res.ok) {
    throw new Error('Failed to fetch pokemon detail');
  }

  return res.json();
}

/**
 * DB 캐싱 로직이 추가될 경우 사용할 Cache-Aside 패턴 예시
 * (현재는 fetch ISR 전략을 사용하지만, 확장성을 위해 구조 유지)
 */
export async function getPokemonListWithDBCache(): Promise<PokemonListResponse> {
  const CACHE_KEY = 'pokemon-list';
  
  // 1. DB 조회 (Cache Lookup)
  const cached = await prisma.pokemonCache.findUnique({
    where: { key: CACHE_KEY },
  });

  // 2. 캐시 히트 시 반환 (Type assertion 사용)
  if (cached) {
    return cached.data as unknown as PokemonListResponse;
  }

  // 3. 캐시 미스 시 API 호출
  const freshData = await getPokemonList(0); // fetch 자체 캐싱은 끄고 DB에 의존

  // 4. DB 저장 (Cache Population)
  await prisma.pokemonCache.upsert({
    where: { key: CACHE_KEY },
    update: { data: freshData as unknown as Prisma.JsonObject },
    create: { key: CACHE_KEY, data: freshData as unknown as Prisma.JsonObject },
  });

  return freshData;
}
```

## 파일: src/app/api/pokemon/route.ts

```typescript
import { NextResponse } from 'next/server';
import { getPokemonList } from '@/lib/api/pokemon';

export async function GET() {
  try {
    // 내부 유틸리티 호출 (ISR 설정이 포함됨)
    const data = await getPokemonList();

    // 응답 헤더에 캐싱 정책 설정
    // s-maxage: CDN(또는 서버)에서 캐싱할 시간
    // stale-while-revalidate: 캐시 만료 후 백그라운드에서 재검증하는 동안 오래된 데이터 제공
    const response = NextResponse.json(data);
    response.headers.set(
      'Cache-Control',
      'public, s-maxage=60, stale-while-revalidate=30'
    );

    return response;
  } catch (error) {
    console.error('API Route Error:', error);
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    );
  }
}
```

## 파일: src/app/page.tsx

```tsx
import { getPokemonList } from '@/lib/api/pokemon';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'; // shadcn/ui 경로 가정
import Image from 'next/image';

// React Server Component (RSC)
export default async function HomePage() {
  // 서버 컴포넌트에서 직접 데이터 페칭
  // lib/api/pokemon.ts의 fetch 옵션(next.revalidate)에 의해 ISR이 동작
  const pokemonList = await getPokemonList();

  return (
    <main className="container mx-auto p-4">
      <h1 className="text-4xl font-bold mb-8 text-center">Pokédex</h1>
      
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
        {pokemonList.results.map((pokemon) => {
          // 이미지 URL 생성 (PokeAPI 공식 아트워크)
          const imageUrl = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${pokemon.id}.png`;

          return (
            <Card key={pokemon.name} className="hover:shadow-lg transition-shadow">
              <CardHeader className="p-0">
                <div className="relative w-full h-48 bg-gray-100 rounded-t-lg">
                  <Image
                    src={imageUrl}
                    alt={pokemon.name}
                    fill
                    className="object-contain p-4"
                    sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                  />
                </div>
              </CardHeader>
              <CardContent className="pt-6">
                <CardTitle className="capitalize text-center text-lg">
                  #{pokemon.id} {pokemon.name}
                </CardTitle>
              </CardContent>
            </Card>
          );
        })}
      </div>
    </main>
  );
}
```
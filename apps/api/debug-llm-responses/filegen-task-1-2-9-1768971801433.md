```markdown
## 파일: e2e/responsive-layout.spec.ts

```typescript
import { test, expect } from '@playwright/test';

// 테스트 대상 URL (Base URL은 config에서 설정)
const TARGET_PAGE = '/';

test.describe('반응형 레이아웃 시각적 회귀 테스트', () => {
  // 공통 테스트 케이스: 모든 해상도에서 수행해야 할 검증
  async function commonLayoutChecks(page) {
    // 1. 카드 내부 이미지 및 텍스트 잘림(Overflow) 검사
    const cards = page.locator('[data-testid="pokemon-card"]');
    const count = await cards.count();
    
    expect(count, '포켓몬 카드가 최소 1개 이상 있어야 합니다.').toBeGreaterThan(0);

    for (let i = 0; i < count; i++) {
      const card = cards.nth(i);
      
      // 카드 내부의 이미지가 로드되었는지 확인
      const img = card.locator('img').first();
      await expect(img, `카드 ${i}번째 이미지가 로드되어야 합니다.`).toBeVisible();
      
      // Next.js Image 최적화 속성 확인 (srcset이 존재하는지 등의 간접 확인)
      // 실제로는 img 태그가 렌더링되고 src가 비어있지 않은지 확인
      const src = await img.getAttribute('src');
      expect(src, `카드 ${i}번째 이미지 소스가 존재해야 합니다.`).toBeTruthy();
    }
  }

  test('모바일 (375px) - 세로 정렬 및 가로 스크롤 없음', async ({ page }) => {
    // 뷰포트 설정
    await page.setViewportSize({ width: 375, height: 667 });
    await page.goto(TARGET_PAGE);

    // 1. 가로 스크롤 발생 여부 확인 (body 너비가 뷰포트 너비보다 크지 않아야 함)
    const bodyWidth = await page.evaluate(() => document.body.scrollWidth);
    expect(bodyWidth).toBeLessThanOrEqual(375);

    // 2. 그리드 컨테이너 확인
    const grid = page.locator('[data-testid="pokemon-grid"]');
    await expect(grid).toBeVisible();

    // 3. 카드들이 세로로 정렬되는지 확인 (모바일에서는 보통 1열)
    // 첫 번째 카드와 두 번째 카드의 Y좌표 차이가 X좌표 차이보다 커야 함 (아래에 위치)
    const firstCard = grid.locator('[data-testid="pokemon-card"]').first();
    const secondCard = grid.locator('[data-testid="pokemon-card"]').nth(1);
    
    const firstBox = await firstCard.boundingBox();
    const secondBox = await secondCard.boundingBox();

    expect(firstBox, '첫 번째 카드가 화면에 보여야 합니다.').toBeDefined();
    expect(secondBox, '두 번째 카드가 화면에 보여야 합니다.').toBeDefined();

    // 세로 정렬 검증: 두 번째 카드가 첫 번째 카드보다 아래에 있어야 함
    expect(secondBox.y).toBeGreaterThan(firstBox.y);
    
    // 공통 검증 (이미지 로딩 등)
    await commonLayoutChecks(page);
  });

  test('태블릿 (768px) - 2열 또는 3열 배치 및 간격 확인', async ({ page }) => {
    await page.setViewportSize({ width: 768, height: 1024 });
    await page.goto(TARGET_PAGE);

    const grid = page.locator('[data-testid="pokemon-grid"]');
    await expect(grid).toBeVisible();

    // 1. 그리드 배치 확인 (2열 또는 3열)
    // 첫 번째 행의 카드들을 가져와서 위치 비교
    const firstCard = grid.locator('[data-testid="pokemon-card"]').first();
    const secondCard = grid.locator('[data-testid="pokemon-card"]').nth(1);
    const thirdCard = grid.locator('[data-testid="pokemon-card"]').nth(2);

    const firstBox = await firstCard.boundingBox();
    const secondBox = await secondCard.boundingBox();
    const thirdBox = await thirdCard.boundingBox();

    expect(firstBox).toBeDefined();
    expect(secondBox).toBeDefined();

    // 두 번째 카드가 첫 번째 카드 옆에 있는지 (Y좌표가 거의 같아야 함)
    expect(Math.abs(secondBox.y - firstBox.y)).toBeLessThan(10); // 오차 범위 10px 이내

    // 간격(Gap)이 일정한지 확인 (단순화된 검증: 두 번째 카드가 첫 번째 카드보다 오른쪽에 있어야 함)
    expect(secondBox.x).toBeGreaterThan(firstBox.x);

    // 세 번째 카드가 있는 경우, 첫 번째/두 번째 카드 아래에 있는지 확인 (줄바꿈 확인)
    if (thirdBox) {
      expect(thirdBox.y).toBeGreaterThan(firstBox.y + 10);
    }

    await commonLayoutChecks(page);
  });

  test('데스크톱 (1920px) - 중앙 정렬 및 다열 배치 확인', async ({ page }) => {
    await page.setViewportSize({ width: 1920, height: 1080 });
    await page.goto(TARGET_PAGE);

    const grid = page.locator('[data-testid="pokemon-grid"]');
    await expect(grid).toBeVisible();

    // 1. 그리드 중앙 정렬 확인
    // 그리드의 너비가 화면 너비보다 작고, 좌우 여백이 있는지 확인
    const gridBox = await grid.boundingBox();
    expect(gridBox, '그리드 박스를 찾을 수 없습니다.').toBeDefined();
    
    // 그리드가 화면보다 작거나 같아야 함 (max-width 적용 확인)
    expect(gridBox.width).toBeLessThanOrEqual(1920);

    // 그리드가 화면 중앙에 위치하는지 확인 (좌우 패딩이 비슷해야 함)
    // 왼쪽 여백과 오른쪽 여백 계산 (대략적인 중앙 정렬 확인)
    const viewportCenter = 1920 / 2;
    const gridCenter = gridBox.x + (gridBox.width / 2);
    expect(Math.abs(gridCenter - viewportCenter)).toBeLessThan(50); // 중앙에서 50px 이내 오차 허용

    // 2. 카드가 여러 열로 분배되는지 확인
    const firstCard = grid.locator('[data-testid="pokemon-card"]').first();
    const fourthCard = grid.locator('[data-testid="pokemon-card"]').nth(3); // 4열 레이아웃 가정

    const firstBox = await firstCard.boundingBox();
    const fourthBox = await fourthCard.boundingBox();

    if (fourthBox) {
      // 4번째 카드가 첫 번째 카드와 같은 행에 있는지 (Y좌표 비교)
      // 만약 3열 레이아웃이라면 4번째 카드는 아래 행에 있을 수 있음.
      // 여기서는 "여러 열"임을 확인하는 것이 목적이므로, 2번째 카드가 옆에 있는지만 확인해도 충분할 수 있음.
      // 하지만 1920px이므로 4열 이상일 가능성이 높음.
      const secondCard = grid.locator('[data-testid="pokemon-card"]').nth(1);
      const secondBox = await secondCard.boundingBox();
      expect(Math.abs(secondBox.y - firstBox.y)).toBeLessThan(10);
    }

    await commonLayoutChecks(page);
  });
});
```

## 파일: playwright.config.ts

```typescript
import { defineConfig, devices } from '@playwright/test';

/**
 * Playwright 테스트 설정
 * @see https://playwright.dev/docs/test-configuration.
 */
export default defineConfig({
  testDir: './e2e',
  /* 병렬로 테스트 실행 */
  fullyParallel: true,
  /* CI에서는 실패 시에만 재시도 */
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  /* 병렬 워커 수 */
  workers: process.env.CI ? 1 : undefined,
  
  /* 테스트 리포터 설정 */
  reporter: 'html',

  /* 공통 타임아웃 설정 (이미지 로딩 고려하여 넉넉하게 설정) */
  timeout: 30 * 1000, // 30초
  expect: {
    timeout: 10 * 1000 // 10초
  },

  use: {
    /* 기본 타임아웃 */
    actionTimeout: 0,
    /* 베이스 URL */
    baseURL: 'http://localhost:3000',
    /* 추적 설정 (CI에서는 재시도 시에만) */
    trace: 'on-first-retry',
    /* 스크린샷 설정 */
    screenshot: 'only-on-failure',
  },

  /* 로컬 개발 서버 실행 설정 */
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
    timeout: 120 * 1000, // 서버 시작 대기 시간
  },

  /* 브라우저 프로젝트 설정 */
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },

    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },

    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },

    /* 모바일 뷰포트 테스트를 위한 별도 프로젝트 (선택 사항, spec 파일에서 viewport를 제어하므로 주석 처리) */
    // {
    //   name: 'Mobile Chrome',
    //   use: { ...devices['Pixel 5'] },
    // },
  ],
});
```

## 파일: src/app/page.tsx

```tsx
import { prisma } from '@/lib/prisma'; // Prisma 클라이언트 경로 가정
import { PokemonCard } from '@/components/pokemon-card';

// 데이터 페칭 함수 (서버 컴포넌트)
async function getPokemonList() {
  try {
    const pokemonList = await prisma.pokemonCache.findMany({
      orderBy: { id: 'asc' },
      take: 20, // 테스트 및 성능을 위해 제한
    });
    return pokemonList;
  } catch (error) {
    console.error('Failed to fetch pokemon:', error);
    return [];
  }
}

export default async function Home() {
  const pokemonList = await getPokemonList();

  return (
    <main className="min-h-screen bg-background p-4 md:p-8">
      <div className="mx-auto max-w-7xl">
        <h1 className="mb-8 text-3xl font-bold text-foreground">Pokédex</h1>
        
        {/* 
          테스트 선택자(data-testid) 추가 
          Grid 레이아웃: 
          - Mobile: 1열 (grid-cols-1)
          - Tablet: 2열 (md:grid-cols-2)
          - Desktop: 3~4열 (lg:grid-cols-3 xl:grid-cols-4)
        */}
        <div 
          data-testid="pokemon-grid"
          className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4"
        >
          {pokemonList.map((pokemon) => (
            <PokemonCard 
              key={pokemon.id} 
              pokemon={pokemon} 
            />
          ))}
        </div>
      </div>
    </main>
  );
}
```

## 파일: src/components/pokemon-card.tsx

```tsx
import Image from 'next/image';
import Link from 'next/link';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'; // shadcn/ui 경로 가정

// Pokemon 타입 정의 (Prisma 모델과 일치하도록 가정)
interface Pokemon {
  id: number;
  name: string;
  types: string[]; // 또는 JSON 타입
  imageUrl: string;
  // 기타 필요한 필드
}

interface PokemonCardProps {
  pokemon: Pokemon;
}

export function PokemonCard({ pokemon }: PokemonCardProps) {
  return (
    <Link href={`/pokemon/${pokemon.id}`} passHref>
      <Card 
        className="group flex h-full flex-col overflow-hidden transition-shadow hover:shadow-lg"
        data-testid="pokemon-card" // 테스트 선택자 추가
      >
        <CardHeader className="p-0">
          {/* 
            이미지 컨테이너: 
            - relative: Next.js Image fill 속성을 위해 필요
            - aspect-square: 정사각형 비율 유지 (반응형 핵심)
          */}
          <div className="relative aspect-square w-full bg-muted">
            <Image
              src={pokemon.imageUrl}
              alt={`${pokemon.name} image`}
              fill
              sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
              className="object-cover transition-transform group-hover:scale-105"
              priority={false} // 첫 화면이 아니라면 false
            />
          </div>
        </CardHeader>
        
        <CardContent className="flex flex-1 flex-col justify-end p-4">
          <CardTitle className="text-xl capitalize">{pokemon.name}</CardTitle>
          <div className="mt-2 flex gap-2">
            {pokemon.types.map((type) => (
              <span 
                key={type} 
                className="rounded-full bg-secondary px-2 py-1 text-xs font-semibold text-secondary-foreground"
              >
                {type}
              </span>
            ))}
          </div>
        </CardContent>
      </Card>
    </Link>
  );
}
```
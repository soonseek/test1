작업을 시작하겠습니다.

이 Task는 `getPokemonList` 로직에 **DB 캐싱 계층(Cache-Aside Pattern)**을 추가하는 것입니다. Prisma Client를 사용하여 `PokemonCache` 테이블을 먼저 확인하고, 데이터가 없거나 오래된 경우에만 PokeAPI를 호출하여 DB에 저장하는 방식으로 구현합니다.

이를 통해 API 호출 비용을 절감하고 응답 속도를 개선할 수 있습니다.

### 구현 전략
1.  **Prisma Client 초기화**: DB 연결을 위한 Singleton 패턴 Prisma 클라이언트 생성.
2.  **캐싱 로직 구현**:
    *   `id`를 기반으로 DB 조회.
    *   데이터가 있으면 반환.
    *   데이터가 없으면 PokeAPI 호출 후 DB 저장 (`upsert` 사용).
3.  **타입 정의**: API 응답과 DB 스키마에 맞는 타입 정의.

아래는 해당 로직이 포함된 파일입니다.

## 파일: src/lib/prisma.ts

```typescript
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: ['query', 'error', 'warn'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

## 파일: src/lib/api/pokemon.ts

```typescript
import { prisma } from '@/lib/prisma';

// PokeAPI 응답 타입 정의
export interface PokemonListItem {
  name: string;
  url: string;
}

export interface PokemonListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokemonListItem[];
}

// Prisma PokemonCache 테이블의 data 필드(Json)와 매핑되는 인터페이스
interface CachedPokemonData {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokemonListItem[];
}

/**
 * 포켓몬 목록을 가져오는 함수 (DB 캐싱 적용)
 * 
 * @param offset - 가져올 데이터의 시작 위치
 * @param limit - 가져올 데이터의 개수 (기본값: 20)
 * @returns PokemonListResponse
 */
export async function getPokemonList(
  offset: number = 0,
  limit: number = 20
): Promise<PokemonListResponse> {
  const cacheId = `list-${offset}-${limit}`;

  try {
    // 1. DB 캐시 조회 시도
    const cachedData = await prisma.pokemonCache.findUnique({
      where: { id: cacheId },
    });

    // 2. 캐시 히트 시 데이터 반환
    if (cachedData) {
      console.log(`[Cache Hit] Pokemon List: ${cacheId}`);
      // JSON 필드를 파싱하여 반환
      return cachedData.data as PokemonListResponse;
    }

    console.log(`[Cache Miss] Fetching from PokeAPI: ${cacheId}`);

    // 3. 캐시 미스 시 PokeAPI 호출
    const response = await fetch(
      `https://pokeapi.co/api/v2/pokemon?offset=${offset}&limit=${limit}`,
      {
        // Next.js의 캐싱 전략 (선택 사항이나 권장)
        next: { revalidate: 3600 }, 
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch data from PokeAPI');
    }

    const data: PokemonListResponse = await response.json();

    // 4. DB에 캐시 저장 (Upsert: 없으면 생성, 있으면 갱신)
    await prisma.pokemonCache.upsert({
      where: { id: cacheId },
      update: {
        data: data as any, // Prisma JsonValue 타입 캐스팅
        updatedAt: new Date(),
      },
      create: {
        id: cacheId,
        data: data as any,
      },
    });

    return data;
  } catch (error) {
    console.error('Error fetching pokemon list:', error);
    throw error;
  }
}
```